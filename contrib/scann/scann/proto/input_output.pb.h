// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/input_output.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "scann/proto/incremental_updates.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2finput_5foutput_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fproto_2finput_5foutput_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scann_2fproto_2finput_5foutput_2eproto;
namespace research_scann {
class InputOutputConfig;
struct InputOutputConfigDefaultTypeInternal;
extern InputOutputConfigDefaultTypeInternal _InputOutputConfig_default_instance_;
class InputOutputConfig_PreprocessingFunction;
struct InputOutputConfig_PreprocessingFunctionDefaultTypeInternal;
extern InputOutputConfig_PreprocessingFunctionDefaultTypeInternal _InputOutputConfig_PreprocessingFunction_default_instance_;
class InputOutputConfig_PureDynamicConfig;
struct InputOutputConfig_PureDynamicConfigDefaultTypeInternal;
extern InputOutputConfig_PureDynamicConfigDefaultTypeInternal _InputOutputConfig_PureDynamicConfig_default_instance_;
}  // namespace research_scann
PROTOBUF_NAMESPACE_OPEN
template<> ::research_scann::InputOutputConfig* Arena::CreateMaybeMessage<::research_scann::InputOutputConfig>(Arena*);
template<> ::research_scann::InputOutputConfig_PreprocessingFunction* Arena::CreateMaybeMessage<::research_scann::InputOutputConfig_PreprocessingFunction>(Arena*);
template<> ::research_scann::InputOutputConfig_PureDynamicConfig* Arena::CreateMaybeMessage<::research_scann::InputOutputConfig_PureDynamicConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace research_scann {

enum InputOutputConfig_PureDynamicConfig_VectorType : int {
  InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE = 0,
  InputOutputConfig_PureDynamicConfig_VectorType_SPARSE = 1,
  InputOutputConfig_PureDynamicConfig_VectorType_DENSE = 2
};
bool InputOutputConfig_PureDynamicConfig_VectorType_IsValid(int value);
constexpr InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MIN = InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE;
constexpr InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX = InputOutputConfig_PureDynamicConfig_VectorType_DENSE;
constexpr int InputOutputConfig_PureDynamicConfig_VectorType_VectorType_ARRAYSIZE = InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_PureDynamicConfig_VectorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_PureDynamicConfig_VectorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_PureDynamicConfig_VectorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_PureDynamicConfig_VectorType_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_PureDynamicConfig_VectorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InputOutputConfig_PureDynamicConfig_VectorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_PureDynamicConfig_VectorType>(
    InputOutputConfig_PureDynamicConfig_VectorType_descriptor(), name, value);
}
enum InputOutputConfig_InMemoryTypes : int {
  InputOutputConfig_InMemoryTypes_INT8 = 0,
  InputOutputConfig_InMemoryTypes_UINT8 = 1,
  InputOutputConfig_InMemoryTypes_INT16 = 2,
  InputOutputConfig_InMemoryTypes_INT32 = 4,
  InputOutputConfig_InMemoryTypes_UINT32 = 5,
  InputOutputConfig_InMemoryTypes_INT64 = 6,
  InputOutputConfig_InMemoryTypes_FLOAT = 8,
  InputOutputConfig_InMemoryTypes_DOUBLE = 9,
  InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED = 255,
  InputOutputConfig_InMemoryTypes_UINT16 PROTOBUF_DEPRECATED_ENUM = 3,
  InputOutputConfig_InMemoryTypes_UINT64 PROTOBUF_DEPRECATED_ENUM = 7
};
bool InputOutputConfig_InMemoryTypes_IsValid(int value);
constexpr InputOutputConfig_InMemoryTypes InputOutputConfig_InMemoryTypes_InMemoryTypes_MIN = InputOutputConfig_InMemoryTypes_INT8;
constexpr InputOutputConfig_InMemoryTypes InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX = InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED;
constexpr int InputOutputConfig_InMemoryTypes_InMemoryTypes_ARRAYSIZE = InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_InMemoryTypes_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_InMemoryTypes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_InMemoryTypes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_InMemoryTypes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_InMemoryTypes_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_InMemoryTypes_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InputOutputConfig_InMemoryTypes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_InMemoryTypes>(
    InputOutputConfig_InMemoryTypes_descriptor(), name, value);
}
enum InputOutputConfig_ArtifactsNamingOption : int {
  InputOutputConfig_ArtifactsNamingOption_HASHED = 0,
  InputOutputConfig_ArtifactsNamingOption_NO_HASH = 1
};
bool InputOutputConfig_ArtifactsNamingOption_IsValid(int value);
constexpr InputOutputConfig_ArtifactsNamingOption InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MIN = InputOutputConfig_ArtifactsNamingOption_HASHED;
constexpr InputOutputConfig_ArtifactsNamingOption InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX = InputOutputConfig_ArtifactsNamingOption_NO_HASH;
constexpr int InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_ARRAYSIZE = InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_ArtifactsNamingOption_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_ArtifactsNamingOption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_ArtifactsNamingOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_ArtifactsNamingOption_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_ArtifactsNamingOption_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_ArtifactsNamingOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InputOutputConfig_ArtifactsNamingOption* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_ArtifactsNamingOption>(
    InputOutputConfig_ArtifactsNamingOption_descriptor(), name, value);
}
enum InputOutputConfig_FeatureNorm : int {
  InputOutputConfig_FeatureNorm_NONE = 0,
  InputOutputConfig_FeatureNorm_UNITL2NORM = 1,
  InputOutputConfig_FeatureNorm_STDGAUSSNORM = 2,
  InputOutputConfig_FeatureNorm_UNITL1NORM = 3
};
bool InputOutputConfig_FeatureNorm_IsValid(int value);
constexpr InputOutputConfig_FeatureNorm InputOutputConfig_FeatureNorm_FeatureNorm_MIN = InputOutputConfig_FeatureNorm_NONE;
constexpr InputOutputConfig_FeatureNorm InputOutputConfig_FeatureNorm_FeatureNorm_MAX = InputOutputConfig_FeatureNorm_UNITL1NORM;
constexpr int InputOutputConfig_FeatureNorm_FeatureNorm_ARRAYSIZE = InputOutputConfig_FeatureNorm_FeatureNorm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_FeatureNorm_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_FeatureNorm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_FeatureNorm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_FeatureNorm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_FeatureNorm_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_FeatureNorm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InputOutputConfig_FeatureNorm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_FeatureNorm>(
    InputOutputConfig_FeatureNorm_descriptor(), name, value);
}
// ===================================================================

class InputOutputConfig_PureDynamicConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig.PureDynamicConfig) */ {
 public:
  inline InputOutputConfig_PureDynamicConfig() : InputOutputConfig_PureDynamicConfig(nullptr) {}
  ~InputOutputConfig_PureDynamicConfig() override;
  explicit constexpr InputOutputConfig_PureDynamicConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputOutputConfig_PureDynamicConfig(const InputOutputConfig_PureDynamicConfig& from);
  InputOutputConfig_PureDynamicConfig(InputOutputConfig_PureDynamicConfig&& from) noexcept
    : InputOutputConfig_PureDynamicConfig() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig_PureDynamicConfig& operator=(const InputOutputConfig_PureDynamicConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig_PureDynamicConfig& operator=(InputOutputConfig_PureDynamicConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputOutputConfig_PureDynamicConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputOutputConfig_PureDynamicConfig* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig_PureDynamicConfig*>(
               &_InputOutputConfig_PureDynamicConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InputOutputConfig_PureDynamicConfig& a, InputOutputConfig_PureDynamicConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig_PureDynamicConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputOutputConfig_PureDynamicConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputOutputConfig_PureDynamicConfig* New() const final {
    return new InputOutputConfig_PureDynamicConfig();
  }

  InputOutputConfig_PureDynamicConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputOutputConfig_PureDynamicConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputOutputConfig_PureDynamicConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InputOutputConfig_PureDynamicConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputOutputConfig_PureDynamicConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.InputOutputConfig.PureDynamicConfig";
  }
  protected:
  explicit InputOutputConfig_PureDynamicConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InputOutputConfig_PureDynamicConfig_VectorType VectorType;
  static constexpr VectorType UNSPECIFIED_VECTOR_TYPE =
    InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE;
  static constexpr VectorType SPARSE =
    InputOutputConfig_PureDynamicConfig_VectorType_SPARSE;
  static constexpr VectorType DENSE =
    InputOutputConfig_PureDynamicConfig_VectorType_DENSE;
  static inline bool VectorType_IsValid(int value) {
    return InputOutputConfig_PureDynamicConfig_VectorType_IsValid(value);
  }
  static constexpr VectorType VectorType_MIN =
    InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MIN;
  static constexpr VectorType VectorType_MAX =
    InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX;
  static constexpr int VectorType_ARRAYSIZE =
    InputOutputConfig_PureDynamicConfig_VectorType_VectorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VectorType_descriptor() {
    return InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
  }
  template<typename T>
  static inline const std::string& VectorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VectorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VectorType_Name.");
    return InputOutputConfig_PureDynamicConfig_VectorType_Name(enum_t_value);
  }
  static inline bool VectorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VectorType* value) {
    return InputOutputConfig_PureDynamicConfig_VectorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionalityFieldNumber = 3,
    kVectorTypeFieldNumber = 2,
    kNumShardsFieldNumber = 1,
  };
  // optional uint64 dimensionality = 3;
  bool has_dimensionality() const;
  private:
  bool _internal_has_dimensionality() const;
  public:
  void clear_dimensionality();
  ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality() const;
  void set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_dimensionality() const;
  void _internal_set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .research_scann.InputOutputConfig.PureDynamicConfig.VectorType vector_type = 2 [default = UNSPECIFIED_VECTOR_TYPE];
  bool has_vector_type() const;
  private:
  bool _internal_has_vector_type() const;
  public:
  void clear_vector_type();
  ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType vector_type() const;
  void set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value);
  private:
  ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType _internal_vector_type() const;
  void _internal_set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value);
  public:

  // optional int32 num_shards = 1 [default = 1];
  bool has_num_shards() const;
  private:
  bool _internal_has_num_shards() const;
  public:
  void clear_num_shards();
  ::PROTOBUF_NAMESPACE_ID::int32 num_shards() const;
  void set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_shards() const;
  void _internal_set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig.PureDynamicConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality_;
  int vector_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_shards_;
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};
// -------------------------------------------------------------------

class InputOutputConfig_PreprocessingFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig.PreprocessingFunction) */ {
 public:
  inline InputOutputConfig_PreprocessingFunction() : InputOutputConfig_PreprocessingFunction(nullptr) {}
  ~InputOutputConfig_PreprocessingFunction() override;
  explicit constexpr InputOutputConfig_PreprocessingFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputOutputConfig_PreprocessingFunction(const InputOutputConfig_PreprocessingFunction& from);
  InputOutputConfig_PreprocessingFunction(InputOutputConfig_PreprocessingFunction&& from) noexcept
    : InputOutputConfig_PreprocessingFunction() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig_PreprocessingFunction& operator=(const InputOutputConfig_PreprocessingFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig_PreprocessingFunction& operator=(InputOutputConfig_PreprocessingFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputOutputConfig_PreprocessingFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputOutputConfig_PreprocessingFunction* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig_PreprocessingFunction*>(
               &_InputOutputConfig_PreprocessingFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InputOutputConfig_PreprocessingFunction& a, InputOutputConfig_PreprocessingFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig_PreprocessingFunction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputOutputConfig_PreprocessingFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputOutputConfig_PreprocessingFunction* New() const final {
    return new InputOutputConfig_PreprocessingFunction();
  }

  InputOutputConfig_PreprocessingFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputOutputConfig_PreprocessingFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputOutputConfig_PreprocessingFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InputOutputConfig_PreprocessingFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputOutputConfig_PreprocessingFunction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.InputOutputConfig.PreprocessingFunction";
  }
  protected:
  explicit InputOutputConfig_PreprocessingFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kConfigAsciiFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string config_ascii = 2;
  bool has_config_ascii() const;
  private:
  bool _internal_has_config_ascii() const;
  public:
  void clear_config_ascii();
  const std::string& config_ascii() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_ascii(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_ascii();
  PROTOBUF_MUST_USE_RESULT std::string* release_config_ascii();
  void set_allocated_config_ascii(std::string* config_ascii);
  private:
  const std::string& _internal_config_ascii() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_ascii(const std::string& value);
  std::string* _internal_mutable_config_ascii();
  public:

  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig.PreprocessingFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_ascii_;
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};
// -------------------------------------------------------------------

class InputOutputConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig) */ {
 public:
  inline InputOutputConfig() : InputOutputConfig(nullptr) {}
  ~InputOutputConfig() override;
  explicit constexpr InputOutputConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputOutputConfig(const InputOutputConfig& from);
  InputOutputConfig(InputOutputConfig&& from) noexcept
    : InputOutputConfig() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig& operator=(const InputOutputConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig& operator=(InputOutputConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputOutputConfig& default_instance() {
    return *internal_default_instance();
  }
  enum IncrementalUpdateMetadataOneofCase {
    kIncrementalUpdateMetadataLocation = 19,
    kIncrementalUpdateMetadata = 22,
    INCREMENTALUPDATEMETADATAONEOF_NOT_SET = 0,
  };

  static inline const InputOutputConfig* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig*>(
               &_InputOutputConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InputOutputConfig& a, InputOutputConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputOutputConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputOutputConfig* New() const final {
    return new InputOutputConfig();
  }

  InputOutputConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputOutputConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputOutputConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InputOutputConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputOutputConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.InputOutputConfig";
  }
  protected:
  explicit InputOutputConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InputOutputConfig_PureDynamicConfig PureDynamicConfig;
  typedef InputOutputConfig_PreprocessingFunction PreprocessingFunction;

  typedef InputOutputConfig_InMemoryTypes InMemoryTypes;
  static constexpr InMemoryTypes INT8 =
    InputOutputConfig_InMemoryTypes_INT8;
  static constexpr InMemoryTypes UINT8 =
    InputOutputConfig_InMemoryTypes_UINT8;
  static constexpr InMemoryTypes INT16 =
    InputOutputConfig_InMemoryTypes_INT16;
  static constexpr InMemoryTypes INT32 =
    InputOutputConfig_InMemoryTypes_INT32;
  static constexpr InMemoryTypes UINT32 =
    InputOutputConfig_InMemoryTypes_UINT32;
  static constexpr InMemoryTypes INT64 =
    InputOutputConfig_InMemoryTypes_INT64;
  static constexpr InMemoryTypes FLOAT =
    InputOutputConfig_InMemoryTypes_FLOAT;
  static constexpr InMemoryTypes DOUBLE =
    InputOutputConfig_InMemoryTypes_DOUBLE;
  static constexpr InMemoryTypes IN_MEMORY_DATA_TYPE_NOT_SPECIFIED =
    InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED;
  PROTOBUF_DEPRECATED_ENUM static constexpr InMemoryTypes UINT16 =
    InputOutputConfig_InMemoryTypes_UINT16;
  PROTOBUF_DEPRECATED_ENUM static constexpr InMemoryTypes UINT64 =
    InputOutputConfig_InMemoryTypes_UINT64;
  static inline bool InMemoryTypes_IsValid(int value) {
    return InputOutputConfig_InMemoryTypes_IsValid(value);
  }
  static constexpr InMemoryTypes InMemoryTypes_MIN =
    InputOutputConfig_InMemoryTypes_InMemoryTypes_MIN;
  static constexpr InMemoryTypes InMemoryTypes_MAX =
    InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX;
  static constexpr int InMemoryTypes_ARRAYSIZE =
    InputOutputConfig_InMemoryTypes_InMemoryTypes_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InMemoryTypes_descriptor() {
    return InputOutputConfig_InMemoryTypes_descriptor();
  }
  template<typename T>
  static inline const std::string& InMemoryTypes_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InMemoryTypes>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InMemoryTypes_Name.");
    return InputOutputConfig_InMemoryTypes_Name(enum_t_value);
  }
  static inline bool InMemoryTypes_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InMemoryTypes* value) {
    return InputOutputConfig_InMemoryTypes_Parse(name, value);
  }

  typedef InputOutputConfig_ArtifactsNamingOption ArtifactsNamingOption;
  static constexpr ArtifactsNamingOption HASHED =
    InputOutputConfig_ArtifactsNamingOption_HASHED;
  static constexpr ArtifactsNamingOption NO_HASH =
    InputOutputConfig_ArtifactsNamingOption_NO_HASH;
  static inline bool ArtifactsNamingOption_IsValid(int value) {
    return InputOutputConfig_ArtifactsNamingOption_IsValid(value);
  }
  static constexpr ArtifactsNamingOption ArtifactsNamingOption_MIN =
    InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MIN;
  static constexpr ArtifactsNamingOption ArtifactsNamingOption_MAX =
    InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX;
  static constexpr int ArtifactsNamingOption_ARRAYSIZE =
    InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ArtifactsNamingOption_descriptor() {
    return InputOutputConfig_ArtifactsNamingOption_descriptor();
  }
  template<typename T>
  static inline const std::string& ArtifactsNamingOption_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ArtifactsNamingOption>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ArtifactsNamingOption_Name.");
    return InputOutputConfig_ArtifactsNamingOption_Name(enum_t_value);
  }
  static inline bool ArtifactsNamingOption_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ArtifactsNamingOption* value) {
    return InputOutputConfig_ArtifactsNamingOption_Parse(name, value);
  }

  typedef InputOutputConfig_FeatureNorm FeatureNorm;
  static constexpr FeatureNorm NONE =
    InputOutputConfig_FeatureNorm_NONE;
  static constexpr FeatureNorm UNITL2NORM =
    InputOutputConfig_FeatureNorm_UNITL2NORM;
  static constexpr FeatureNorm STDGAUSSNORM =
    InputOutputConfig_FeatureNorm_STDGAUSSNORM;
  static constexpr FeatureNorm UNITL1NORM =
    InputOutputConfig_FeatureNorm_UNITL1NORM;
  static inline bool FeatureNorm_IsValid(int value) {
    return InputOutputConfig_FeatureNorm_IsValid(value);
  }
  static constexpr FeatureNorm FeatureNorm_MIN =
    InputOutputConfig_FeatureNorm_FeatureNorm_MIN;
  static constexpr FeatureNorm FeatureNorm_MAX =
    InputOutputConfig_FeatureNorm_FeatureNorm_MAX;
  static constexpr int FeatureNorm_ARRAYSIZE =
    InputOutputConfig_FeatureNorm_FeatureNorm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FeatureNorm_descriptor() {
    return InputOutputConfig_FeatureNorm_descriptor();
  }
  template<typename T>
  static inline const std::string& FeatureNorm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FeatureNorm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FeatureNorm_Name.");
    return InputOutputConfig_FeatureNorm_Name(enum_t_value);
  }
  static inline bool FeatureNorm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FeatureNorm* value) {
    return InputOutputConfig_FeatureNorm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseWildcardFieldNumber = 3,
    kQueryWildcardFieldNumber = 8,
    kOutputSstableWildcardFieldNumber = 11,
    kHashedDatabaseWildcardFieldNumber = 12,
    kTokenizedDatabaseWildcardFieldNumber = 14,
    kFixedPointDatabaseWildcardFieldNumber = 17,
    kPreprocessedArtifactsDirFieldNumber = 18,
    kMemoryConsumptionEstimateFilenameFieldNumber = 24,
    kQueryPreprocessingFunctionFieldNumber = 16,
    kPureDynamicConfigFieldNumber = 21,
    kDimensionalityFieldNumber = 4,
    kNormTypeFieldNumber = 5,
    kAllowTwoPassReadFieldNumber = 15,
    kNonNegativeFieldNumber = 6,
    kIsDenseFieldNumber = 7,
    kSaturateFieldNumber = 10,
    kArtifactsNamingOptionFieldNumber = 23,
    kInMemoryDataTypeFieldNumber = 2,
    kIncrementalUpdateMetadataLocationFieldNumber = 19,
    kIncrementalUpdateMetadataFieldNumber = 22,
  };
  // optional string database_wildcard = 3;
  bool has_database_wildcard() const;
  private:
  bool _internal_has_database_wildcard() const;
  public:
  void clear_database_wildcard();
  const std::string& database_wildcard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_wildcard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_wildcard();
  PROTOBUF_MUST_USE_RESULT std::string* release_database_wildcard();
  void set_allocated_database_wildcard(std::string* database_wildcard);
  private:
  const std::string& _internal_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_wildcard(const std::string& value);
  std::string* _internal_mutable_database_wildcard();
  public:

  // optional string query_wildcard = 8;
  bool has_query_wildcard() const;
  private:
  bool _internal_has_query_wildcard() const;
  public:
  void clear_query_wildcard();
  const std::string& query_wildcard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query_wildcard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query_wildcard();
  PROTOBUF_MUST_USE_RESULT std::string* release_query_wildcard();
  void set_allocated_query_wildcard(std::string* query_wildcard);
  private:
  const std::string& _internal_query_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_wildcard(const std::string& value);
  std::string* _internal_mutable_query_wildcard();
  public:

  // optional string output_sstable_wildcard = 11;
  bool has_output_sstable_wildcard() const;
  private:
  bool _internal_has_output_sstable_wildcard() const;
  public:
  void clear_output_sstable_wildcard();
  const std::string& output_sstable_wildcard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_sstable_wildcard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_sstable_wildcard();
  PROTOBUF_MUST_USE_RESULT std::string* release_output_sstable_wildcard();
  void set_allocated_output_sstable_wildcard(std::string* output_sstable_wildcard);
  private:
  const std::string& _internal_output_sstable_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_sstable_wildcard(const std::string& value);
  std::string* _internal_mutable_output_sstable_wildcard();
  public:

  // optional string hashed_database_wildcard = 12;
  bool has_hashed_database_wildcard() const;
  private:
  bool _internal_has_hashed_database_wildcard() const;
  public:
  void clear_hashed_database_wildcard();
  const std::string& hashed_database_wildcard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hashed_database_wildcard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hashed_database_wildcard();
  PROTOBUF_MUST_USE_RESULT std::string* release_hashed_database_wildcard();
  void set_allocated_hashed_database_wildcard(std::string* hashed_database_wildcard);
  private:
  const std::string& _internal_hashed_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashed_database_wildcard(const std::string& value);
  std::string* _internal_mutable_hashed_database_wildcard();
  public:

  // optional string tokenized_database_wildcard = 14;
  bool has_tokenized_database_wildcard() const;
  private:
  bool _internal_has_tokenized_database_wildcard() const;
  public:
  void clear_tokenized_database_wildcard();
  const std::string& tokenized_database_wildcard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokenized_database_wildcard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokenized_database_wildcard();
  PROTOBUF_MUST_USE_RESULT std::string* release_tokenized_database_wildcard();
  void set_allocated_tokenized_database_wildcard(std::string* tokenized_database_wildcard);
  private:
  const std::string& _internal_tokenized_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokenized_database_wildcard(const std::string& value);
  std::string* _internal_mutable_tokenized_database_wildcard();
  public:

  // optional string fixed_point_database_wildcard = 17;
  bool has_fixed_point_database_wildcard() const;
  private:
  bool _internal_has_fixed_point_database_wildcard() const;
  public:
  void clear_fixed_point_database_wildcard();
  const std::string& fixed_point_database_wildcard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fixed_point_database_wildcard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fixed_point_database_wildcard();
  PROTOBUF_MUST_USE_RESULT std::string* release_fixed_point_database_wildcard();
  void set_allocated_fixed_point_database_wildcard(std::string* fixed_point_database_wildcard);
  private:
  const std::string& _internal_fixed_point_database_wildcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_point_database_wildcard(const std::string& value);
  std::string* _internal_mutable_fixed_point_database_wildcard();
  public:

  // optional string preprocessed_artifacts_dir = 18;
  bool has_preprocessed_artifacts_dir() const;
  private:
  bool _internal_has_preprocessed_artifacts_dir() const;
  public:
  void clear_preprocessed_artifacts_dir();
  const std::string& preprocessed_artifacts_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preprocessed_artifacts_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preprocessed_artifacts_dir();
  PROTOBUF_MUST_USE_RESULT std::string* release_preprocessed_artifacts_dir();
  void set_allocated_preprocessed_artifacts_dir(std::string* preprocessed_artifacts_dir);
  private:
  const std::string& _internal_preprocessed_artifacts_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preprocessed_artifacts_dir(const std::string& value);
  std::string* _internal_mutable_preprocessed_artifacts_dir();
  public:

  // optional string memory_consumption_estimate_filename = 24;
  bool has_memory_consumption_estimate_filename() const;
  private:
  bool _internal_has_memory_consumption_estimate_filename() const;
  public:
  void clear_memory_consumption_estimate_filename();
  const std::string& memory_consumption_estimate_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_consumption_estimate_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_consumption_estimate_filename();
  PROTOBUF_MUST_USE_RESULT std::string* release_memory_consumption_estimate_filename();
  void set_allocated_memory_consumption_estimate_filename(std::string* memory_consumption_estimate_filename);
  private:
  const std::string& _internal_memory_consumption_estimate_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_consumption_estimate_filename(const std::string& value);
  std::string* _internal_mutable_memory_consumption_estimate_filename();
  public:

  // optional .research_scann.InputOutputConfig.PreprocessingFunction query_preprocessing_function = 16;
  bool has_query_preprocessing_function() const;
  private:
  bool _internal_has_query_preprocessing_function() const;
  public:
  void clear_query_preprocessing_function();
  const ::research_scann::InputOutputConfig_PreprocessingFunction& query_preprocessing_function() const;
  PROTOBUF_MUST_USE_RESULT ::research_scann::InputOutputConfig_PreprocessingFunction* release_query_preprocessing_function();
  ::research_scann::InputOutputConfig_PreprocessingFunction* mutable_query_preprocessing_function();
  void set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function);
  private:
  const ::research_scann::InputOutputConfig_PreprocessingFunction& _internal_query_preprocessing_function() const;
  ::research_scann::InputOutputConfig_PreprocessingFunction* _internal_mutable_query_preprocessing_function();
  public:
  void unsafe_arena_set_allocated_query_preprocessing_function(
      ::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function);
  ::research_scann::InputOutputConfig_PreprocessingFunction* unsafe_arena_release_query_preprocessing_function();

  // optional .research_scann.InputOutputConfig.PureDynamicConfig pure_dynamic_config = 21;
  bool has_pure_dynamic_config() const;
  private:
  bool _internal_has_pure_dynamic_config() const;
  public:
  void clear_pure_dynamic_config();
  const ::research_scann::InputOutputConfig_PureDynamicConfig& pure_dynamic_config() const;
  PROTOBUF_MUST_USE_RESULT ::research_scann::InputOutputConfig_PureDynamicConfig* release_pure_dynamic_config();
  ::research_scann::InputOutputConfig_PureDynamicConfig* mutable_pure_dynamic_config();
  void set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config);
  private:
  const ::research_scann::InputOutputConfig_PureDynamicConfig& _internal_pure_dynamic_config() const;
  ::research_scann::InputOutputConfig_PureDynamicConfig* _internal_mutable_pure_dynamic_config();
  public:
  void unsafe_arena_set_allocated_pure_dynamic_config(
      ::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config);
  ::research_scann::InputOutputConfig_PureDynamicConfig* unsafe_arena_release_pure_dynamic_config();

  // optional uint64 dimensionality = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_dimensionality() const;
  private:
  bool _internal_has_dimensionality() const;
  public:
  PROTOBUF_DEPRECATED void clear_dimensionality();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality() const;
  PROTOBUF_DEPRECATED void set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_dimensionality() const;
  void _internal_set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .research_scann.InputOutputConfig.FeatureNorm norm_type = 5 [default = NONE];
  bool has_norm_type() const;
  private:
  bool _internal_has_norm_type() const;
  public:
  void clear_norm_type();
  ::research_scann::InputOutputConfig_FeatureNorm norm_type() const;
  void set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value);
  private:
  ::research_scann::InputOutputConfig_FeatureNorm _internal_norm_type() const;
  void _internal_set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value);
  public:

  // optional bool allow_two_pass_read = 15 [default = false];
  bool has_allow_two_pass_read() const;
  private:
  bool _internal_has_allow_two_pass_read() const;
  public:
  void clear_allow_two_pass_read();
  bool allow_two_pass_read() const;
  void set_allow_two_pass_read(bool value);
  private:
  bool _internal_allow_two_pass_read() const;
  void _internal_set_allow_two_pass_read(bool value);
  public:

  // optional bool non_negative = 6 [default = false];
  bool has_non_negative() const;
  private:
  bool _internal_has_non_negative() const;
  public:
  void clear_non_negative();
  bool non_negative() const;
  void set_non_negative(bool value);
  private:
  bool _internal_non_negative() const;
  void _internal_set_non_negative(bool value);
  public:

  // optional bool is_dense = 7;
  bool has_is_dense() const;
  private:
  bool _internal_has_is_dense() const;
  public:
  void clear_is_dense();
  bool is_dense() const;
  void set_is_dense(bool value);
  private:
  bool _internal_is_dense() const;
  void _internal_set_is_dense(bool value);
  public:

  // optional bool saturate = 10 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_saturate() const;
  private:
  bool _internal_has_saturate() const;
  public:
  PROTOBUF_DEPRECATED void clear_saturate();
  PROTOBUF_DEPRECATED bool saturate() const;
  PROTOBUF_DEPRECATED void set_saturate(bool value);
  private:
  bool _internal_saturate() const;
  void _internal_set_saturate(bool value);
  public:

  // optional .research_scann.InputOutputConfig.ArtifactsNamingOption artifacts_naming_option = 23 [default = HASHED];
  bool has_artifacts_naming_option() const;
  private:
  bool _internal_has_artifacts_naming_option() const;
  public:
  void clear_artifacts_naming_option();
  ::research_scann::InputOutputConfig_ArtifactsNamingOption artifacts_naming_option() const;
  void set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value);
  private:
  ::research_scann::InputOutputConfig_ArtifactsNamingOption _internal_artifacts_naming_option() const;
  void _internal_set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value);
  public:

  // optional .research_scann.InputOutputConfig.InMemoryTypes in_memory_data_type = 2 [default = IN_MEMORY_DATA_TYPE_NOT_SPECIFIED];
  bool has_in_memory_data_type() const;
  private:
  bool _internal_has_in_memory_data_type() const;
  public:
  void clear_in_memory_data_type();
  ::research_scann::InputOutputConfig_InMemoryTypes in_memory_data_type() const;
  void set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value);
  private:
  ::research_scann::InputOutputConfig_InMemoryTypes _internal_in_memory_data_type() const;
  void _internal_set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value);
  public:

  // string incremental_update_metadata_location = 19;
  bool has_incremental_update_metadata_location() const;
  private:
  bool _internal_has_incremental_update_metadata_location() const;
  public:
  void clear_incremental_update_metadata_location();
  const std::string& incremental_update_metadata_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_incremental_update_metadata_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_incremental_update_metadata_location();
  PROTOBUF_MUST_USE_RESULT std::string* release_incremental_update_metadata_location();
  void set_allocated_incremental_update_metadata_location(std::string* incremental_update_metadata_location);
  private:
  const std::string& _internal_incremental_update_metadata_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_incremental_update_metadata_location(const std::string& value);
  std::string* _internal_mutable_incremental_update_metadata_location();
  public:

  // .research_scann.IncrementalUpdateMetadata incremental_update_metadata = 22;
  bool has_incremental_update_metadata() const;
  private:
  bool _internal_has_incremental_update_metadata() const;
  public:
  void clear_incremental_update_metadata();
  const ::research_scann::IncrementalUpdateMetadata& incremental_update_metadata() const;
  PROTOBUF_MUST_USE_RESULT ::research_scann::IncrementalUpdateMetadata* release_incremental_update_metadata();
  ::research_scann::IncrementalUpdateMetadata* mutable_incremental_update_metadata();
  void set_allocated_incremental_update_metadata(::research_scann::IncrementalUpdateMetadata* incremental_update_metadata);
  private:
  const ::research_scann::IncrementalUpdateMetadata& _internal_incremental_update_metadata() const;
  ::research_scann::IncrementalUpdateMetadata* _internal_mutable_incremental_update_metadata();
  public:
  void unsafe_arena_set_allocated_incremental_update_metadata(
      ::research_scann::IncrementalUpdateMetadata* incremental_update_metadata);
  ::research_scann::IncrementalUpdateMetadata* unsafe_arena_release_incremental_update_metadata();

  void clear_IncrementalUpdateMetadataOneof();
  IncrementalUpdateMetadataOneofCase IncrementalUpdateMetadataOneof_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig)
 private:
  class _Internal;
  void set_has_incremental_update_metadata_location();
  void set_has_incremental_update_metadata();

  inline bool has_IncrementalUpdateMetadataOneof() const;
  inline void clear_has_IncrementalUpdateMetadataOneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_sstable_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashed_database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokenized_database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixed_point_database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preprocessed_artifacts_dir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_consumption_estimate_filename_;
  ::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function_;
  ::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality_;
  int norm_type_;
  bool allow_two_pass_read_;
  bool non_negative_;
  bool is_dense_;
  bool saturate_;
  int artifacts_naming_option_;
  int in_memory_data_type_;
  union IncrementalUpdateMetadataOneofUnion {
    constexpr IncrementalUpdateMetadataOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr incremental_update_metadata_location_;
    ::research_scann::IncrementalUpdateMetadata* incremental_update_metadata_;
  } IncrementalUpdateMetadataOneof_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InputOutputConfig_PureDynamicConfig

// optional int32 num_shards = 1 [default = 1];
inline bool InputOutputConfig_PureDynamicConfig::_internal_has_num_shards() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InputOutputConfig_PureDynamicConfig::has_num_shards() const {
  return _internal_has_num_shards();
}
inline void InputOutputConfig_PureDynamicConfig::clear_num_shards() {
  num_shards_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputOutputConfig_PureDynamicConfig::_internal_num_shards() const {
  return num_shards_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputOutputConfig_PureDynamicConfig::num_shards() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.num_shards)
  return _internal_num_shards();
}
inline void InputOutputConfig_PureDynamicConfig::_internal_set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_shards_ = value;
}
inline void InputOutputConfig_PureDynamicConfig::set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_shards(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.num_shards)
}

// optional .research_scann.InputOutputConfig.PureDynamicConfig.VectorType vector_type = 2 [default = UNSPECIFIED_VECTOR_TYPE];
inline bool InputOutputConfig_PureDynamicConfig::_internal_has_vector_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InputOutputConfig_PureDynamicConfig::has_vector_type() const {
  return _internal_has_vector_type();
}
inline void InputOutputConfig_PureDynamicConfig::clear_vector_type() {
  vector_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig::_internal_vector_type() const {
  return static_cast< ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType >(vector_type_);
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig::vector_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.vector_type)
  return _internal_vector_type();
}
inline void InputOutputConfig_PureDynamicConfig::_internal_set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value) {
  assert(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  vector_type_ = value;
}
inline void InputOutputConfig_PureDynamicConfig::set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value) {
  _internal_set_vector_type(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.vector_type)
}

// optional uint64 dimensionality = 3;
inline bool InputOutputConfig_PureDynamicConfig::_internal_has_dimensionality() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputOutputConfig_PureDynamicConfig::has_dimensionality() const {
  return _internal_has_dimensionality();
}
inline void InputOutputConfig_PureDynamicConfig::clear_dimensionality() {
  dimensionality_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputOutputConfig_PureDynamicConfig::_internal_dimensionality() const {
  return dimensionality_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputOutputConfig_PureDynamicConfig::dimensionality() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.dimensionality)
  return _internal_dimensionality();
}
inline void InputOutputConfig_PureDynamicConfig::_internal_set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  dimensionality_ = value;
}
inline void InputOutputConfig_PureDynamicConfig::set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_dimensionality(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.dimensionality)
}

// -------------------------------------------------------------------

// InputOutputConfig_PreprocessingFunction

// optional string name = 1;
inline bool InputOutputConfig_PreprocessingFunction::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputOutputConfig_PreprocessingFunction::has_name() const {
  return _internal_has_name();
}
inline void InputOutputConfig_PreprocessingFunction::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::name() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PreprocessingFunction.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig_PreprocessingFunction::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PreprocessingFunction.name)
}
inline std::string* InputOutputConfig_PreprocessingFunction::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.PreprocessingFunction.name)
  return _s;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::_internal_name() const {
  return name_.Get();
}
inline void InputOutputConfig_PreprocessingFunction::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig_PreprocessingFunction::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig_PreprocessingFunction::release_name() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.PreprocessingFunction.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig_PreprocessingFunction::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.PreprocessingFunction.name)
}

// optional string config_ascii = 2;
inline bool InputOutputConfig_PreprocessingFunction::_internal_has_config_ascii() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InputOutputConfig_PreprocessingFunction::has_config_ascii() const {
  return _internal_has_config_ascii();
}
inline void InputOutputConfig_PreprocessingFunction::clear_config_ascii() {
  config_ascii_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::config_ascii() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  return _internal_config_ascii();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig_PreprocessingFunction::set_config_ascii(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 config_ascii_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}
inline std::string* InputOutputConfig_PreprocessingFunction::mutable_config_ascii() {
  std::string* _s = _internal_mutable_config_ascii();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  return _s;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::_internal_config_ascii() const {
  return config_ascii_.Get();
}
inline void InputOutputConfig_PreprocessingFunction::_internal_set_config_ascii(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  config_ascii_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig_PreprocessingFunction::_internal_mutable_config_ascii() {
  _has_bits_[0] |= 0x00000002u;
  return config_ascii_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig_PreprocessingFunction::release_config_ascii() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  if (!_internal_has_config_ascii()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return config_ascii_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig_PreprocessingFunction::set_allocated_config_ascii(std::string* config_ascii) {
  if (config_ascii != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  config_ascii_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_ascii,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}

// -------------------------------------------------------------------

// InputOutputConfig

// optional .research_scann.InputOutputConfig.InMemoryTypes in_memory_data_type = 2 [default = IN_MEMORY_DATA_TYPE_NOT_SPECIFIED];
inline bool InputOutputConfig::_internal_has_in_memory_data_type() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool InputOutputConfig::has_in_memory_data_type() const {
  return _internal_has_in_memory_data_type();
}
inline void InputOutputConfig::clear_in_memory_data_type() {
  in_memory_data_type_ = 255;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::research_scann::InputOutputConfig_InMemoryTypes InputOutputConfig::_internal_in_memory_data_type() const {
  return static_cast< ::research_scann::InputOutputConfig_InMemoryTypes >(in_memory_data_type_);
}
inline ::research_scann::InputOutputConfig_InMemoryTypes InputOutputConfig::in_memory_data_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.in_memory_data_type)
  return _internal_in_memory_data_type();
}
inline void InputOutputConfig::_internal_set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value) {
  assert(::research_scann::InputOutputConfig_InMemoryTypes_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  in_memory_data_type_ = value;
}
inline void InputOutputConfig::set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value) {
  _internal_set_in_memory_data_type(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.in_memory_data_type)
}

// optional string database_wildcard = 3;
inline bool InputOutputConfig::_internal_has_database_wildcard() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputOutputConfig::has_database_wildcard() const {
  return _internal_has_database_wildcard();
}
inline void InputOutputConfig::clear_database_wildcard() {
  database_wildcard_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputOutputConfig::database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.database_wildcard)
  return _internal_database_wildcard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_database_wildcard(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.database_wildcard)
}
inline std::string* InputOutputConfig::mutable_database_wildcard() {
  std::string* _s = _internal_mutable_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_database_wildcard() const {
  return database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_database_wildcard() {
  _has_bits_[0] |= 0x00000001u;
  return database_wildcard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.database_wildcard)
  if (!_internal_has_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_wildcard_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_database_wildcard(std::string* database_wildcard) {
  if (database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_wildcard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_wildcard,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.database_wildcard)
}

// optional bool allow_two_pass_read = 15 [default = false];
inline bool InputOutputConfig::_internal_has_allow_two_pass_read() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool InputOutputConfig::has_allow_two_pass_read() const {
  return _internal_has_allow_two_pass_read();
}
inline void InputOutputConfig::clear_allow_two_pass_read() {
  allow_two_pass_read_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool InputOutputConfig::_internal_allow_two_pass_read() const {
  return allow_two_pass_read_;
}
inline bool InputOutputConfig::allow_two_pass_read() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.allow_two_pass_read)
  return _internal_allow_two_pass_read();
}
inline void InputOutputConfig::_internal_set_allow_two_pass_read(bool value) {
  _has_bits_[0] |= 0x00001000u;
  allow_two_pass_read_ = value;
}
inline void InputOutputConfig::set_allow_two_pass_read(bool value) {
  _internal_set_allow_two_pass_read(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.allow_two_pass_read)
}

// optional string query_wildcard = 8;
inline bool InputOutputConfig::_internal_has_query_wildcard() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InputOutputConfig::has_query_wildcard() const {
  return _internal_has_query_wildcard();
}
inline void InputOutputConfig::clear_query_wildcard() {
  query_wildcard_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputOutputConfig::query_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.query_wildcard)
  return _internal_query_wildcard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_query_wildcard(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 query_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.query_wildcard)
}
inline std::string* InputOutputConfig::mutable_query_wildcard() {
  std::string* _s = _internal_mutable_query_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.query_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_query_wildcard() const {
  return query_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_query_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  query_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_query_wildcard() {
  _has_bits_[0] |= 0x00000002u;
  return query_wildcard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_query_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.query_wildcard)
  if (!_internal_has_query_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return query_wildcard_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_query_wildcard(std::string* query_wildcard) {
  if (query_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  query_wildcard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query_wildcard,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.query_wildcard)
}

// string incremental_update_metadata_location = 19;
inline bool InputOutputConfig::_internal_has_incremental_update_metadata_location() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadataLocation;
}
inline bool InputOutputConfig::has_incremental_update_metadata_location() const {
  return _internal_has_incremental_update_metadata_location();
}
inline void InputOutputConfig::set_has_incremental_update_metadata_location() {
  _oneof_case_[0] = kIncrementalUpdateMetadataLocation;
}
inline void InputOutputConfig::clear_incremental_update_metadata_location() {
  if (_internal_has_incremental_update_metadata_location()) {
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_IncrementalUpdateMetadataOneof();
  }
}
inline const std::string& InputOutputConfig::incremental_update_metadata_location() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.incremental_update_metadata_location)
  return _internal_incremental_update_metadata_location();
}
template <typename ArgT0, typename... ArgT>
inline void InputOutputConfig::set_incremental_update_metadata_location(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.incremental_update_metadata_location)
}
inline std::string* InputOutputConfig::mutable_incremental_update_metadata_location() {
  std::string* _s = _internal_mutable_incremental_update_metadata_location();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.incremental_update_metadata_location)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_incremental_update_metadata_location() const {
  if (_internal_has_incremental_update_metadata_location()) {
    return IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InputOutputConfig::_internal_set_incremental_update_metadata_location(const std::string& value) {
  if (!_internal_has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_incremental_update_metadata_location() {
  if (!_internal_has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_incremental_update_metadata_location() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.incremental_update_metadata_location)
  if (_internal_has_incremental_update_metadata_location()) {
    clear_has_IncrementalUpdateMetadataOneof();
    return IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void InputOutputConfig::set_allocated_incremental_update_metadata_location(std::string* incremental_update_metadata_location) {
  if (has_IncrementalUpdateMetadataOneof()) {
    clear_IncrementalUpdateMetadataOneof();
  }
  if (incremental_update_metadata_location != nullptr) {
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(incremental_update_metadata_location);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(incremental_update_metadata_location);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.incremental_update_metadata_location)
}

// .research_scann.IncrementalUpdateMetadata incremental_update_metadata = 22;
inline bool InputOutputConfig::_internal_has_incremental_update_metadata() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadata;
}
inline bool InputOutputConfig::has_incremental_update_metadata() const {
  return _internal_has_incremental_update_metadata();
}
inline void InputOutputConfig::set_has_incremental_update_metadata() {
  _oneof_case_[0] = kIncrementalUpdateMetadata;
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::release_incremental_update_metadata() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.incremental_update_metadata)
  if (_internal_has_incremental_update_metadata()) {
    clear_has_IncrementalUpdateMetadataOneof();
      ::research_scann::IncrementalUpdateMetadata* temp = IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::research_scann::IncrementalUpdateMetadata& InputOutputConfig::_internal_incremental_update_metadata() const {
  return _internal_has_incremental_update_metadata()
      ? *IncrementalUpdateMetadataOneof_.incremental_update_metadata_
      : reinterpret_cast< ::research_scann::IncrementalUpdateMetadata&>(::research_scann::_IncrementalUpdateMetadata_default_instance_);
}
inline const ::research_scann::IncrementalUpdateMetadata& InputOutputConfig::incremental_update_metadata() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.incremental_update_metadata)
  return _internal_incremental_update_metadata();
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::unsafe_arena_release_incremental_update_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:research_scann.InputOutputConfig.incremental_update_metadata)
  if (_internal_has_incremental_update_metadata()) {
    clear_has_IncrementalUpdateMetadataOneof();
    ::research_scann::IncrementalUpdateMetadata* temp = IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputOutputConfig::unsafe_arena_set_allocated_incremental_update_metadata(::research_scann::IncrementalUpdateMetadata* incremental_update_metadata) {
  clear_IncrementalUpdateMetadataOneof();
  if (incremental_update_metadata) {
    set_has_incremental_update_metadata();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = incremental_update_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.InputOutputConfig.incremental_update_metadata)
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::_internal_mutable_incremental_update_metadata() {
  if (!_internal_has_incremental_update_metadata()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = CreateMaybeMessage< ::research_scann::IncrementalUpdateMetadata >(GetArenaForAllocation());
  }
  return IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::mutable_incremental_update_metadata() {
  ::research_scann::IncrementalUpdateMetadata* _msg = _internal_mutable_incremental_update_metadata();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.incremental_update_metadata)
  return _msg;
}

// optional string output_sstable_wildcard = 11;
inline bool InputOutputConfig::_internal_has_output_sstable_wildcard() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InputOutputConfig::has_output_sstable_wildcard() const {
  return _internal_has_output_sstable_wildcard();
}
inline void InputOutputConfig::clear_output_sstable_wildcard() {
  output_sstable_wildcard_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InputOutputConfig::output_sstable_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.output_sstable_wildcard)
  return _internal_output_sstable_wildcard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_output_sstable_wildcard(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 output_sstable_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.output_sstable_wildcard)
}
inline std::string* InputOutputConfig::mutable_output_sstable_wildcard() {
  std::string* _s = _internal_mutable_output_sstable_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.output_sstable_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_output_sstable_wildcard() const {
  return output_sstable_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_output_sstable_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  output_sstable_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_output_sstable_wildcard() {
  _has_bits_[0] |= 0x00000004u;
  return output_sstable_wildcard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_output_sstable_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.output_sstable_wildcard)
  if (!_internal_has_output_sstable_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return output_sstable_wildcard_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_output_sstable_wildcard(std::string* output_sstable_wildcard) {
  if (output_sstable_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  output_sstable_wildcard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), output_sstable_wildcard,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.output_sstable_wildcard)
}

// optional string preprocessed_artifacts_dir = 18;
inline bool InputOutputConfig::_internal_has_preprocessed_artifacts_dir() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InputOutputConfig::has_preprocessed_artifacts_dir() const {
  return _internal_has_preprocessed_artifacts_dir();
}
inline void InputOutputConfig::clear_preprocessed_artifacts_dir() {
  preprocessed_artifacts_dir_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& InputOutputConfig::preprocessed_artifacts_dir() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  return _internal_preprocessed_artifacts_dir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_preprocessed_artifacts_dir(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 preprocessed_artifacts_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}
inline std::string* InputOutputConfig::mutable_preprocessed_artifacts_dir() {
  std::string* _s = _internal_mutable_preprocessed_artifacts_dir();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_preprocessed_artifacts_dir() const {
  return preprocessed_artifacts_dir_.Get();
}
inline void InputOutputConfig::_internal_set_preprocessed_artifacts_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  preprocessed_artifacts_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_preprocessed_artifacts_dir() {
  _has_bits_[0] |= 0x00000040u;
  return preprocessed_artifacts_dir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_preprocessed_artifacts_dir() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  if (!_internal_has_preprocessed_artifacts_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return preprocessed_artifacts_dir_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_preprocessed_artifacts_dir(std::string* preprocessed_artifacts_dir) {
  if (preprocessed_artifacts_dir != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  preprocessed_artifacts_dir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), preprocessed_artifacts_dir,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}

// optional .research_scann.InputOutputConfig.ArtifactsNamingOption artifacts_naming_option = 23 [default = HASHED];
inline bool InputOutputConfig::_internal_has_artifacts_naming_option() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool InputOutputConfig::has_artifacts_naming_option() const {
  return _internal_has_artifacts_naming_option();
}
inline void InputOutputConfig::clear_artifacts_naming_option() {
  artifacts_naming_option_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::research_scann::InputOutputConfig_ArtifactsNamingOption InputOutputConfig::_internal_artifacts_naming_option() const {
  return static_cast< ::research_scann::InputOutputConfig_ArtifactsNamingOption >(artifacts_naming_option_);
}
inline ::research_scann::InputOutputConfig_ArtifactsNamingOption InputOutputConfig::artifacts_naming_option() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.artifacts_naming_option)
  return _internal_artifacts_naming_option();
}
inline void InputOutputConfig::_internal_set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value) {
  assert(::research_scann::InputOutputConfig_ArtifactsNamingOption_IsValid(value));
  _has_bits_[0] |= 0x00010000u;
  artifacts_naming_option_ = value;
}
inline void InputOutputConfig::set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value) {
  _internal_set_artifacts_naming_option(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.artifacts_naming_option)
}

// optional .research_scann.InputOutputConfig.PureDynamicConfig pure_dynamic_config = 21;
inline bool InputOutputConfig::_internal_has_pure_dynamic_config() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || pure_dynamic_config_ != nullptr);
  return value;
}
inline bool InputOutputConfig::has_pure_dynamic_config() const {
  return _internal_has_pure_dynamic_config();
}
inline void InputOutputConfig::clear_pure_dynamic_config() {
  if (pure_dynamic_config_ != nullptr) pure_dynamic_config_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::research_scann::InputOutputConfig_PureDynamicConfig& InputOutputConfig::_internal_pure_dynamic_config() const {
  const ::research_scann::InputOutputConfig_PureDynamicConfig* p = pure_dynamic_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::InputOutputConfig_PureDynamicConfig&>(
      ::research_scann::_InputOutputConfig_PureDynamicConfig_default_instance_);
}
inline const ::research_scann::InputOutputConfig_PureDynamicConfig& InputOutputConfig::pure_dynamic_config() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.pure_dynamic_config)
  return _internal_pure_dynamic_config();
}
inline void InputOutputConfig::unsafe_arena_set_allocated_pure_dynamic_config(
    ::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pure_dynamic_config_);
  }
  pure_dynamic_config_ = pure_dynamic_config;
  if (pure_dynamic_config) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.InputOutputConfig.pure_dynamic_config)
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::release_pure_dynamic_config() {
  _has_bits_[0] &= ~0x00000200u;
  ::research_scann::InputOutputConfig_PureDynamicConfig* temp = pure_dynamic_config_;
  pure_dynamic_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::unsafe_arena_release_pure_dynamic_config() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.pure_dynamic_config)
  _has_bits_[0] &= ~0x00000200u;
  ::research_scann::InputOutputConfig_PureDynamicConfig* temp = pure_dynamic_config_;
  pure_dynamic_config_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::_internal_mutable_pure_dynamic_config() {
  _has_bits_[0] |= 0x00000200u;
  if (pure_dynamic_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig_PureDynamicConfig>(GetArenaForAllocation());
    pure_dynamic_config_ = p;
  }
  return pure_dynamic_config_;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::mutable_pure_dynamic_config() {
  ::research_scann::InputOutputConfig_PureDynamicConfig* _msg = _internal_mutable_pure_dynamic_config();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.pure_dynamic_config)
  return _msg;
}
inline void InputOutputConfig::set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pure_dynamic_config_;
  }
  if (pure_dynamic_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::research_scann::InputOutputConfig_PureDynamicConfig>::GetOwningArena(pure_dynamic_config);
    if (message_arena != submessage_arena) {
      pure_dynamic_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pure_dynamic_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  pure_dynamic_config_ = pure_dynamic_config;
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.pure_dynamic_config)
}

// optional .research_scann.InputOutputConfig.FeatureNorm norm_type = 5 [default = NONE];
inline bool InputOutputConfig::_internal_has_norm_type() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool InputOutputConfig::has_norm_type() const {
  return _internal_has_norm_type();
}
inline void InputOutputConfig::clear_norm_type() {
  norm_type_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::research_scann::InputOutputConfig_FeatureNorm InputOutputConfig::_internal_norm_type() const {
  return static_cast< ::research_scann::InputOutputConfig_FeatureNorm >(norm_type_);
}
inline ::research_scann::InputOutputConfig_FeatureNorm InputOutputConfig::norm_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.norm_type)
  return _internal_norm_type();
}
inline void InputOutputConfig::_internal_set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value) {
  assert(::research_scann::InputOutputConfig_FeatureNorm_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  norm_type_ = value;
}
inline void InputOutputConfig::set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value) {
  _internal_set_norm_type(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.norm_type)
}

// optional bool non_negative = 6 [default = false];
inline bool InputOutputConfig::_internal_has_non_negative() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool InputOutputConfig::has_non_negative() const {
  return _internal_has_non_negative();
}
inline void InputOutputConfig::clear_non_negative() {
  non_negative_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool InputOutputConfig::_internal_non_negative() const {
  return non_negative_;
}
inline bool InputOutputConfig::non_negative() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.non_negative)
  return _internal_non_negative();
}
inline void InputOutputConfig::_internal_set_non_negative(bool value) {
  _has_bits_[0] |= 0x00002000u;
  non_negative_ = value;
}
inline void InputOutputConfig::set_non_negative(bool value) {
  _internal_set_non_negative(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.non_negative)
}

// optional bool is_dense = 7;
inline bool InputOutputConfig::_internal_has_is_dense() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool InputOutputConfig::has_is_dense() const {
  return _internal_has_is_dense();
}
inline void InputOutputConfig::clear_is_dense() {
  is_dense_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool InputOutputConfig::_internal_is_dense() const {
  return is_dense_;
}
inline bool InputOutputConfig::is_dense() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.is_dense)
  return _internal_is_dense();
}
inline void InputOutputConfig::_internal_set_is_dense(bool value) {
  _has_bits_[0] |= 0x00004000u;
  is_dense_ = value;
}
inline void InputOutputConfig::set_is_dense(bool value) {
  _internal_set_is_dense(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.is_dense)
}

// optional .research_scann.InputOutputConfig.PreprocessingFunction query_preprocessing_function = 16;
inline bool InputOutputConfig::_internal_has_query_preprocessing_function() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || query_preprocessing_function_ != nullptr);
  return value;
}
inline bool InputOutputConfig::has_query_preprocessing_function() const {
  return _internal_has_query_preprocessing_function();
}
inline void InputOutputConfig::clear_query_preprocessing_function() {
  if (query_preprocessing_function_ != nullptr) query_preprocessing_function_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::research_scann::InputOutputConfig_PreprocessingFunction& InputOutputConfig::_internal_query_preprocessing_function() const {
  const ::research_scann::InputOutputConfig_PreprocessingFunction* p = query_preprocessing_function_;
  return p != nullptr ? *p : reinterpret_cast<const ::research_scann::InputOutputConfig_PreprocessingFunction&>(
      ::research_scann::_InputOutputConfig_PreprocessingFunction_default_instance_);
}
inline const ::research_scann::InputOutputConfig_PreprocessingFunction& InputOutputConfig::query_preprocessing_function() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.query_preprocessing_function)
  return _internal_query_preprocessing_function();
}
inline void InputOutputConfig::unsafe_arena_set_allocated_query_preprocessing_function(
    ::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_preprocessing_function_);
  }
  query_preprocessing_function_ = query_preprocessing_function;
  if (query_preprocessing_function) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:research_scann.InputOutputConfig.query_preprocessing_function)
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::release_query_preprocessing_function() {
  _has_bits_[0] &= ~0x00000100u;
  ::research_scann::InputOutputConfig_PreprocessingFunction* temp = query_preprocessing_function_;
  query_preprocessing_function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::unsafe_arena_release_query_preprocessing_function() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.query_preprocessing_function)
  _has_bits_[0] &= ~0x00000100u;
  ::research_scann::InputOutputConfig_PreprocessingFunction* temp = query_preprocessing_function_;
  query_preprocessing_function_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::_internal_mutable_query_preprocessing_function() {
  _has_bits_[0] |= 0x00000100u;
  if (query_preprocessing_function_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig_PreprocessingFunction>(GetArenaForAllocation());
    query_preprocessing_function_ = p;
  }
  return query_preprocessing_function_;
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::mutable_query_preprocessing_function() {
  ::research_scann::InputOutputConfig_PreprocessingFunction* _msg = _internal_mutable_query_preprocessing_function();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.query_preprocessing_function)
  return _msg;
}
inline void InputOutputConfig::set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete query_preprocessing_function_;
  }
  if (query_preprocessing_function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::research_scann::InputOutputConfig_PreprocessingFunction>::GetOwningArena(query_preprocessing_function);
    if (message_arena != submessage_arena) {
      query_preprocessing_function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_preprocessing_function, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  query_preprocessing_function_ = query_preprocessing_function;
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.query_preprocessing_function)
}

// optional string hashed_database_wildcard = 12;
inline bool InputOutputConfig::_internal_has_hashed_database_wildcard() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InputOutputConfig::has_hashed_database_wildcard() const {
  return _internal_has_hashed_database_wildcard();
}
inline void InputOutputConfig::clear_hashed_database_wildcard() {
  hashed_database_wildcard_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InputOutputConfig::hashed_database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.hashed_database_wildcard)
  return _internal_hashed_database_wildcard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_hashed_database_wildcard(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 hashed_database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.hashed_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_hashed_database_wildcard() {
  std::string* _s = _internal_mutable_hashed_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.hashed_database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_hashed_database_wildcard() const {
  return hashed_database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_hashed_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  hashed_database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_hashed_database_wildcard() {
  _has_bits_[0] |= 0x00000008u;
  return hashed_database_wildcard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_hashed_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.hashed_database_wildcard)
  if (!_internal_has_hashed_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return hashed_database_wildcard_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_hashed_database_wildcard(std::string* hashed_database_wildcard) {
  if (hashed_database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hashed_database_wildcard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hashed_database_wildcard,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.hashed_database_wildcard)
}

// optional string fixed_point_database_wildcard = 17;
inline bool InputOutputConfig::_internal_has_fixed_point_database_wildcard() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InputOutputConfig::has_fixed_point_database_wildcard() const {
  return _internal_has_fixed_point_database_wildcard();
}
inline void InputOutputConfig::clear_fixed_point_database_wildcard() {
  fixed_point_database_wildcard_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InputOutputConfig::fixed_point_database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  return _internal_fixed_point_database_wildcard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_fixed_point_database_wildcard(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 fixed_point_database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_fixed_point_database_wildcard() {
  std::string* _s = _internal_mutable_fixed_point_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_fixed_point_database_wildcard() const {
  return fixed_point_database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_fixed_point_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  fixed_point_database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_fixed_point_database_wildcard() {
  _has_bits_[0] |= 0x00000020u;
  return fixed_point_database_wildcard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_fixed_point_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  if (!_internal_has_fixed_point_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return fixed_point_database_wildcard_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_fixed_point_database_wildcard(std::string* fixed_point_database_wildcard) {
  if (fixed_point_database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  fixed_point_database_wildcard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fixed_point_database_wildcard,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}

// optional string tokenized_database_wildcard = 14;
inline bool InputOutputConfig::_internal_has_tokenized_database_wildcard() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InputOutputConfig::has_tokenized_database_wildcard() const {
  return _internal_has_tokenized_database_wildcard();
}
inline void InputOutputConfig::clear_tokenized_database_wildcard() {
  tokenized_database_wildcard_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InputOutputConfig::tokenized_database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.tokenized_database_wildcard)
  return _internal_tokenized_database_wildcard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_tokenized_database_wildcard(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 tokenized_database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.tokenized_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_tokenized_database_wildcard() {
  std::string* _s = _internal_mutable_tokenized_database_wildcard();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.tokenized_database_wildcard)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_tokenized_database_wildcard() const {
  return tokenized_database_wildcard_.Get();
}
inline void InputOutputConfig::_internal_set_tokenized_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  tokenized_database_wildcard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_tokenized_database_wildcard() {
  _has_bits_[0] |= 0x00000010u;
  return tokenized_database_wildcard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_tokenized_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.tokenized_database_wildcard)
  if (!_internal_has_tokenized_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return tokenized_database_wildcard_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_tokenized_database_wildcard(std::string* tokenized_database_wildcard) {
  if (tokenized_database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  tokenized_database_wildcard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tokenized_database_wildcard,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.tokenized_database_wildcard)
}

// optional string memory_consumption_estimate_filename = 24;
inline bool InputOutputConfig::_internal_has_memory_consumption_estimate_filename() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InputOutputConfig::has_memory_consumption_estimate_filename() const {
  return _internal_has_memory_consumption_estimate_filename();
}
inline void InputOutputConfig::clear_memory_consumption_estimate_filename() {
  memory_consumption_estimate_filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& InputOutputConfig::memory_consumption_estimate_filename() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  return _internal_memory_consumption_estimate_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputOutputConfig::set_memory_consumption_estimate_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 memory_consumption_estimate_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}
inline std::string* InputOutputConfig::mutable_memory_consumption_estimate_filename() {
  std::string* _s = _internal_mutable_memory_consumption_estimate_filename();
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  return _s;
}
inline const std::string& InputOutputConfig::_internal_memory_consumption_estimate_filename() const {
  return memory_consumption_estimate_filename_.Get();
}
inline void InputOutputConfig::_internal_set_memory_consumption_estimate_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  memory_consumption_estimate_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::_internal_mutable_memory_consumption_estimate_filename() {
  _has_bits_[0] |= 0x00000080u;
  return memory_consumption_estimate_filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputOutputConfig::release_memory_consumption_estimate_filename() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  if (!_internal_has_memory_consumption_estimate_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return memory_consumption_estimate_filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputOutputConfig::set_allocated_memory_consumption_estimate_filename(std::string* memory_consumption_estimate_filename) {
  if (memory_consumption_estimate_filename != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  memory_consumption_estimate_filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memory_consumption_estimate_filename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}

// optional bool saturate = 10 [default = false, deprecated = true];
inline bool InputOutputConfig::_internal_has_saturate() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool InputOutputConfig::has_saturate() const {
  return _internal_has_saturate();
}
inline void InputOutputConfig::clear_saturate() {
  saturate_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool InputOutputConfig::_internal_saturate() const {
  return saturate_;
}
inline bool InputOutputConfig::saturate() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.saturate)
  return _internal_saturate();
}
inline void InputOutputConfig::_internal_set_saturate(bool value) {
  _has_bits_[0] |= 0x00008000u;
  saturate_ = value;
}
inline void InputOutputConfig::set_saturate(bool value) {
  _internal_set_saturate(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.saturate)
}

// optional uint64 dimensionality = 4 [deprecated = true];
inline bool InputOutputConfig::_internal_has_dimensionality() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool InputOutputConfig::has_dimensionality() const {
  return _internal_has_dimensionality();
}
inline void InputOutputConfig::clear_dimensionality() {
  dimensionality_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputOutputConfig::_internal_dimensionality() const {
  return dimensionality_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputOutputConfig::dimensionality() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.dimensionality)
  return _internal_dimensionality();
}
inline void InputOutputConfig::_internal_set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  dimensionality_ = value;
}
inline void InputOutputConfig::set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_dimensionality(value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.dimensionality)
}

inline bool InputOutputConfig::has_IncrementalUpdateMetadataOneof() const {
  return IncrementalUpdateMetadataOneof_case() != INCREMENTALUPDATEMETADATAONEOF_NOT_SET;
}
inline void InputOutputConfig::clear_has_IncrementalUpdateMetadataOneof() {
  _oneof_case_[0] = INCREMENTALUPDATEMETADATAONEOF_NOT_SET;
}
inline InputOutputConfig::IncrementalUpdateMetadataOneofCase InputOutputConfig::IncrementalUpdateMetadataOneof_case() const {
  return InputOutputConfig::IncrementalUpdateMetadataOneofCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace research_scann

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType>() {
  return ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::InputOutputConfig_InMemoryTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_InMemoryTypes>() {
  return ::research_scann::InputOutputConfig_InMemoryTypes_descriptor();
}
template <> struct is_proto_enum< ::research_scann::InputOutputConfig_ArtifactsNamingOption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_ArtifactsNamingOption>() {
  return ::research_scann::InputOutputConfig_ArtifactsNamingOption_descriptor();
}
template <> struct is_proto_enum< ::research_scann::InputOutputConfig_FeatureNorm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_FeatureNorm>() {
  return ::research_scann::InputOutputConfig_FeatureNorm_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto
