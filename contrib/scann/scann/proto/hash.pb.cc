// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/hash.proto

#include "scann/proto/hash.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace research_scann {
constexpr HashConfig::HashConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parameters_filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , projection_(nullptr)
  , asymmetric_hash_(nullptr)
  , min_hash_(nullptr)
  , pca_hash_(nullptr)
  , bit_sampling_hash_(nullptr)
  , bnc_hash_(nullptr)
  , num_bits_(0)
  , threshold_type_(1)
{}
struct HashConfigDefaultTypeInternal {
  constexpr HashConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HashConfigDefaultTypeInternal() {}
  union {
    HashConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HashConfigDefaultTypeInternal _HashConfig_default_instance_;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions::AsymmetricHasherConfig_FixedPointLUTConversionOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : float_to_int_conversion_method_(0)

  , multiplier_quantile_(1){}
struct AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal {
  constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal() {}
  union {
    AsymmetricHasherConfig_FixedPointLUTConversionOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal _AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_;
constexpr AsymmetricHasherConfig::AsymmetricHasherConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : centers_filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , mr_jobname_prefix_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cell_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , projection_(nullptr)
  , quantization_distance_(nullptr)
  , stacked_quantizers_config_(nullptr)
  , fixed_point_lut_conversion_options_(nullptr)
  , min_number_machines_(0)
  , use_per_leaf_partition_training_(false)
  , use_noise_shaped_training_(false)
  , use_single_machine_trainer_(false)
  , lookup_type_(0)

  , quantization_scheme_(0)

  , partition_level_confidence_interval_stdevs_(0)
  , num_machines_(0)
  , use_residual_quantization_(false)
  , use_normalized_residual_quantization_(false)
  , use_norm_biasing_correction_(false)
  , use_global_topn_(false)
  , min_cluster_size_(1)
  , num_clusters_per_block_(256)
  , max_sample_size_(2147483647)
  , max_clustering_iterations_(10)
  , clustering_convergence_tolerance_(1e-05f)
  , clustering_seed_(1)
  , sampling_seed_(1)
  , ram_gb_(4)
  , num_cpus_(1)
  , noise_shaping_threshold_(std::numeric_limits<double>::quiet_NaN())
  , _oneof_case_{}{}
struct AsymmetricHasherConfigDefaultTypeInternal {
  constexpr AsymmetricHasherConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymmetricHasherConfigDefaultTypeInternal() {}
  union {
    AsymmetricHasherConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymmetricHasherConfigDefaultTypeInternal _AsymmetricHasherConfig_default_instance_;
constexpr MinHasherConfig::MinHasherConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seeds_()
  , config_id_(0)
  , num_sketches_(0)
  , num_hashes_(0)
  , num_bits_per_hash_(0){}
struct MinHasherConfigDefaultTypeInternal {
  constexpr MinHasherConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MinHasherConfigDefaultTypeInternal() {}
  union {
    MinHasherConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MinHasherConfigDefaultTypeInternal _MinHasherConfig_default_instance_;
constexpr BitSamplingHasherConfig::BitSamplingHasherConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : use_entropy_(false)
  , num_bits_(3){}
struct BitSamplingHasherConfigDefaultTypeInternal {
  constexpr BitSamplingHasherConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BitSamplingHasherConfigDefaultTypeInternal() {}
  union {
    BitSamplingHasherConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BitSamplingHasherConfigDefaultTypeInternal _BitSamplingHasherConfig_default_instance_;
constexpr PcaHasherConfig::PcaHasherConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : rotate_projections_(false)
  , learn_projections_(false)
  , max_sample_size_(0)
  , sampling_fraction_(1)
  , sampling_seed_(1)
  , max_num_iteration_(40)
  , iteration_tolerance_(1e-05f){}
struct PcaHasherConfigDefaultTypeInternal {
  constexpr PcaHasherConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PcaHasherConfigDefaultTypeInternal() {}
  union {
    PcaHasherConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PcaHasherConfigDefaultTypeInternal _PcaHasherConfig_default_instance_;
constexpr BncHasherConfig::BncHasherConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : compression_ratio_(0)
  , num_cpus_(1)
  , gamma_(10)
  , learning_rate_(0.1f)
  , batch_size_(128)
  , num_phase1_iterations_(50)
  , num_phase2_iterations_(100)
  , sampling_seed_(1){}
struct BncHasherConfigDefaultTypeInternal {
  constexpr BncHasherConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BncHasherConfigDefaultTypeInternal() {}
  union {
    BncHasherConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BncHasherConfigDefaultTypeInternal _BncHasherConfig_default_instance_;
constexpr StackedQuantizersConfig::StackedQuantizersConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : relative_improvement_threshold_(0.001f)
  , min_num_iterations_(3)
  , max_num_iterations_(10){}
struct StackedQuantizersConfigDefaultTypeInternal {
  constexpr StackedQuantizersConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StackedQuantizersConfigDefaultTypeInternal() {}
  union {
    StackedQuantizersConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StackedQuantizersConfigDefaultTypeInternal _StackedQuantizersConfig_default_instance_;
}  // namespace research_scann
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_scann_2fproto_2fhash_2eproto[8];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_scann_2fproto_2fhash_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_scann_2fproto_2fhash_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, num_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, projection_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, threshold_type_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, parameters_filename_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, asymmetric_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, min_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, pca_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, bit_sampling_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, bnc_hash_),
  7,
  1,
  8,
  0,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, float_to_int_conversion_method_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, multiplier_quantile_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, projection_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, num_clusters_per_block_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, lookup_type_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, clustering_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_residual_quantization_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_normalized_residual_quantization_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, noise_shaping_threshold_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_norm_biasing_correction_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_global_topn_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, fixed_point_lut_conversion_options_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, sampling_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, quantization_distance_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, max_clustering_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, clustering_convergence_tolerance_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, centers_filename_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, num_machines_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_per_leaf_partition_training_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, mr_jobname_prefix_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, cell_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, ram_gb_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, num_cpus_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, quantization_scheme_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, stacked_quantizers_config_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, min_number_machines_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, max_sample_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_noise_shaped_training_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, partition_level_confidence_interval_stdevs_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, min_cluster_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_single_machine_trainer_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, SamplingFractionOrExpectedSize_),
  3,
  20,
  11,
  24,
  15,
  16,
  28,
  17,
  18,
  6,
  ~0u,
  ~0u,
  25,
  4,
  22,
  23,
  0,
  14,
  8,
  1,
  2,
  26,
  27,
  12,
  5,
  7,
  21,
  9,
  13,
  19,
  10,
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, config_id_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, num_sketches_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, num_hashes_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, seeds_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, num_bits_per_hash_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, num_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, use_entropy_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, rotate_projections_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, sampling_fraction_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, sampling_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, max_sample_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, learn_projections_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, max_num_iteration_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, iteration_tolerance_),
  0,
  3,
  4,
  2,
  1,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, compression_ratio_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, gamma_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, learning_rate_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, batch_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, num_phase1_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, num_phase2_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, sampling_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, num_cpus_),
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  1,
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, min_num_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, max_num_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, relative_improvement_threshold_),
  1,
  2,
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 14, sizeof(::research_scann::HashConfig)},
  { 23, 30, sizeof(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions)},
  { 32, 69, sizeof(::research_scann::AsymmetricHasherConfig)},
  { 100, 110, sizeof(::research_scann::MinHasherConfig)},
  { 115, 122, sizeof(::research_scann::BitSamplingHasherConfig)},
  { 124, 136, sizeof(::research_scann::PcaHasherConfig)},
  { 143, 156, sizeof(::research_scann::BncHasherConfig)},
  { 164, 172, sizeof(::research_scann::StackedQuantizersConfig)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_HashConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_AsymmetricHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_MinHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_BitSamplingHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_PcaHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_BncHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_StackedQuantizersConfig_default_instance_),
};

const char descriptor_table_protodef_scann_2fproto_2fhash_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026scann/proto/hash.proto\022\016research_scann"
  "\032\"scann/proto/distance_measure.proto\032\034sc"
  "ann/proto/projection.proto\"\245\004\n\nHashConfi"
  "g\022\020\n\010num_bits\030\001 \001(\005\0224\n\nprojection\030\002 \001(\0132"
  " .research_scann.ProjectionConfig\022F\n\016thr"
  "eshold_type\030\003 \001(\0162(.research_scann.HashC"
  "onfig.ThresholdType:\004SIGN\022\033\n\023parameters_"
  "filename\030\004 \001(\t\022\?\n\017asymmetric_hash\030\005 \001(\0132"
  "&.research_scann.AsymmetricHasherConfig\022"
  "1\n\010min_hash\030\006 \001(\0132\037.research_scann.MinHa"
  "sherConfig\0221\n\010pca_hash\030\007 \001(\0132\037.research_"
  "scann.PcaHasherConfig\022B\n\021bit_sampling_ha"
  "sh\030\t \001(\0132\'.research_scann.BitSamplingHas"
  "herConfig\0221\n\010bnc_hash\030\n \001(\0132\037.research_s"
  "cann.BncHasherConfig\"L\n\rThresholdType\022\013\n"
  "\007UNKNOWN\020\000\022\010\n\004SIGN\020\001\022\010\n\004MEAN\020\002\022\n\n\006MEDIAN"
  "\020\003\022\016\n\nSINUSOIDAL\020\004\"\302\016\n\026AsymmetricHasherC"
  "onfig\0224\n\nprojection\030\001 \001(\0132 .research_sca"
  "nn.ProjectionConfig\022#\n\026num_clusters_per_"
  "block\030\002 \001(\005:\003256\022M\n\013lookup_type\030\024 \001(\01621."
  "research_scann.AsymmetricHasherConfig.Lo"
  "okupType:\005FLOAT\022\032\n\017clustering_seed\030\t \001(\005"
  ":\0011\022(\n\031use_residual_quantization\030\026 \001(\010:\005"
  "false\0223\n$use_normalized_residual_quantiz"
  "ation\030  \001(\010:\005false\022$\n\027noise_shaping_thre"
  "shold\030\034 \001(\001:\003nan\022*\n\033use_norm_biasing_cor"
  "rection\030\037 \001(\010:\005false\022\036\n\017use_global_topn\030"
  "! \001(\010:\005false\022q\n\"fixed_point_lut_conversi"
  "on_options\030\031 \001(\0132E.research_scann.Asymme"
  "tricHasherConfig.FixedPointLUTConversion"
  "Options\022\036\n\021sampling_fraction\030\n \001(\002:\0011H\000\022"
  "\036\n\024expected_sample_size\030\035 \001(\005H\000\022\030\n\rsampl"
  "ing_seed\030\013 \001(\005:\0011\022D\n\025quantization_distan"
  "ce\030\022 \001(\0132%.research_scann.DistanceMeasur"
  "eConfig\022%\n\031max_clustering_iterations\030\004 \001"
  "(\005:\00210\022/\n clustering_convergence_toleran"
  "ce\030\005 \001(\002:\0051e-05\022\030\n\020centers_filename\030\006 \001("
  "\t\022\024\n\014num_machines\030\033 \001(\005\022.\n\037use_per_leaf_"
  "partition_training\030\021 \001(\010:\005false\022\031\n\021mr_jo"
  "bname_prefix\030\014 \001(\t\022\014\n\004cell\030\r \001(\t\022\021\n\006ram_"
  "gb\030\016 \001(\005:\0014\022\023\n\010num_cpus\030\017 \001(\005:\0011\022_\n\023quan"
  "tization_scheme\030\027 \001(\01629.research_scann.A"
  "symmetricHasherConfig.QuantizationScheme"
  ":\007PRODUCT\022J\n\031stacked_quantizers_config\030\030"
  " \001(\0132\'.research_scann.StackedQuantizersC"
  "onfig\022\037\n\023min_number_machines\030\007 \001(\005B\002\030\001\022#"
  "\n\017max_sample_size\030\003 \001(\005:\n2147483647\022,\n\031u"
  "se_noise_shaped_training\030\036 \001(\010:\005falseB\002\030"
  "\001\0229\n*partition_level_confidence_interval"
  "_stdevs\030\032 \001(\002:\0010B\002\030\001\022\037\n\020min_cluster_size"
  "\030\023 \001(\002:\0011B\002\030\001\022-\n\032use_single_machine_trai"
  "ner\030\010 \001(\010:\005falseB\002\030\001\032\214\002\n\036FixedPointLUTCo"
  "nversionOptions\022\222\001\n\036float_to_int_convers"
  "ion_method\030\001 \001(\0162`.research_scann.Asymme"
  "tricHasherConfig.FixedPointLUTConversion"
  "Options.FloatToIntConversionMethod:\010TRUN"
  "CATE\022\036\n\023multiplier_quantile\030\002 \001(\002:\0011\"5\n\032"
  "FloatToIntConversionMethod\022\014\n\010TRUNCATE\020\000"
  "\022\t\n\005ROUND\020\001\"<\n\nLookupType\022\t\n\005FLOAT\020\000\022\010\n\004"
  "INT8\020\001\022\t\n\005INT16\020\002\022\016\n\nINT8_LUT16\020\003\"Z\n\022Qua"
  "ntizationScheme\022\013\n\007PRODUCT\020\000\022\013\n\007STACKED\020"
  "\001\022\024\n\020PRODUCT_AND_BIAS\020\002\022\024\n\020PRODUCT_AND_P"
  "ACK\020\003B \n\036SamplingFractionOrExpectedSize\""
  "x\n\017MinHasherConfig\022\021\n\tconfig_id\030\001 \001(\005\022\024\n"
  "\014num_sketches\030\002 \001(\005\022\022\n\nnum_hashes\030\003 \001(\005\022"
  "\r\n\005seeds\030\004 \003(\003\022\031\n\021num_bits_per_hash\030\005 \001("
  "\005\"a\n\027BitSamplingHasherConfig\022\023\n\010num_bits"
  "\030\001 \001(\005:\0013\022\032\n\013use_entropy\030\002 \001(\010:\005falseJ\004\010"
  "\003\020\004R\017chunked_hamming\"\352\001\n\017PcaHasherConfig"
  "\022!\n\022rotate_projections\030\001 \001(\010:\005false\022\034\n\021s"
  "ampling_fraction\030\002 \001(\002:\0011\022\030\n\rsampling_se"
  "ed\030\003 \001(\005:\0011\022\027\n\017max_sample_size\030\004 \001(\005\022 \n\021"
  "learn_projections\030\005 \001(\010:\005false\022\035\n\021max_nu"
  "m_iteration\030\006 \001(\005:\00240\022\"\n\023iteration_toler"
  "ance\030\007 \001(\002:\0051e-05\"\355\001\n\017BncHasherConfig\022\034\n"
  "\021compression_ratio\030\001 \001(\002:\0010\022\021\n\005gamma\030\002 \001"
  "(\002:\00210\022\032\n\rlearning_rate\030\003 \001(\002:\0030.1\022\027\n\nba"
  "tch_size\030\004 \001(\005:\003128\022!\n\025num_phase1_iterat"
  "ions\030\005 \001(\005:\00250\022\"\n\025num_phase2_iterations\030"
  "\006 \001(\005:\003100\022\030\n\rsampling_seed\030\007 \001(\005:\0011\022\023\n\010"
  "num_cpus\030\010 \001(\005:\0011\"\207\001\n\027StackedQuantizersC"
  "onfig\022\035\n\022min_num_iterations\030\001 \001(\005:\0013\022\036\n\022"
  "max_num_iterations\030\002 \001(\005:\00210\022-\n\036relative"
  "_improvement_threshold\030\003 \001(\002:\0050.001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_scann_2fproto_2fhash_2eproto_deps[2] = {
  &::descriptor_table_scann_2fproto_2fdistance_5fmeasure_2eproto,
  &::descriptor_table_scann_2fproto_2fprojection_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_scann_2fproto_2fhash_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scann_2fproto_2fhash_2eproto = {
  false, false, 3355, descriptor_table_protodef_scann_2fproto_2fhash_2eproto, "scann/proto/hash.proto", 
  &descriptor_table_scann_2fproto_2fhash_2eproto_once, descriptor_table_scann_2fproto_2fhash_2eproto_deps, 2, 8,
  schemas, file_default_instances, TableStruct_scann_2fproto_2fhash_2eproto::offsets,
  file_level_metadata_scann_2fproto_2fhash_2eproto, file_level_enum_descriptors_scann_2fproto_2fhash_2eproto, file_level_service_descriptors_scann_2fproto_2fhash_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_scann_2fproto_2fhash_2eproto_getter() {
  return &descriptor_table_scann_2fproto_2fhash_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_scann_2fproto_2fhash_2eproto(&descriptor_table_scann_2fproto_2fhash_2eproto);
namespace research_scann {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HashConfig_ThresholdType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[0];
}
bool HashConfig_ThresholdType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr HashConfig_ThresholdType HashConfig::UNKNOWN;
constexpr HashConfig_ThresholdType HashConfig::SIGN;
constexpr HashConfig_ThresholdType HashConfig::MEAN;
constexpr HashConfig_ThresholdType HashConfig::MEDIAN;
constexpr HashConfig_ThresholdType HashConfig::SINUSOIDAL;
constexpr HashConfig_ThresholdType HashConfig::ThresholdType_MIN;
constexpr HashConfig_ThresholdType HashConfig::ThresholdType_MAX;
constexpr int HashConfig::ThresholdType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[1];
}
bool AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::TRUNCATE;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::ROUND;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::FloatToIntConversionMethod_MIN;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::FloatToIntConversionMethod_MAX;
constexpr int AsymmetricHasherConfig_FixedPointLUTConversionOptions::FloatToIntConversionMethod_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_LookupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[2];
}
bool AsymmetricHasherConfig_LookupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::FLOAT;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::INT8;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::INT16;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::INT8_LUT16;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::LookupType_MIN;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::LookupType_MAX;
constexpr int AsymmetricHasherConfig::LookupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_QuantizationScheme_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[3];
}
bool AsymmetricHasherConfig_QuantizationScheme_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::PRODUCT;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::STACKED;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::PRODUCT_AND_BIAS;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::PRODUCT_AND_PACK;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::QuantizationScheme_MIN;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::QuantizationScheme_MAX;
constexpr int AsymmetricHasherConfig::QuantizationScheme_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class HashConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<HashConfig>()._has_bits_);
  static void set_has_num_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::research_scann::ProjectionConfig& projection(const HashConfig* msg);
  static void set_has_projection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_threshold_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_parameters_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::research_scann::AsymmetricHasherConfig& asymmetric_hash(const HashConfig* msg);
  static void set_has_asymmetric_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::research_scann::MinHasherConfig& min_hash(const HashConfig* msg);
  static void set_has_min_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::research_scann::PcaHasherConfig& pca_hash(const HashConfig* msg);
  static void set_has_pca_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::research_scann::BitSamplingHasherConfig& bit_sampling_hash(const HashConfig* msg);
  static void set_has_bit_sampling_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::research_scann::BncHasherConfig& bnc_hash(const HashConfig* msg);
  static void set_has_bnc_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::research_scann::ProjectionConfig&
HashConfig::_Internal::projection(const HashConfig* msg) {
  return *msg->projection_;
}
const ::research_scann::AsymmetricHasherConfig&
HashConfig::_Internal::asymmetric_hash(const HashConfig* msg) {
  return *msg->asymmetric_hash_;
}
const ::research_scann::MinHasherConfig&
HashConfig::_Internal::min_hash(const HashConfig* msg) {
  return *msg->min_hash_;
}
const ::research_scann::PcaHasherConfig&
HashConfig::_Internal::pca_hash(const HashConfig* msg) {
  return *msg->pca_hash_;
}
const ::research_scann::BitSamplingHasherConfig&
HashConfig::_Internal::bit_sampling_hash(const HashConfig* msg) {
  return *msg->bit_sampling_hash_;
}
const ::research_scann::BncHasherConfig&
HashConfig::_Internal::bnc_hash(const HashConfig* msg) {
  return *msg->bnc_hash_;
}
void HashConfig::clear_projection() {
  if (projection_ != nullptr) projection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
HashConfig::HashConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.HashConfig)
}
HashConfig::HashConfig(const HashConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parameters_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_parameters_filename()) {
    parameters_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_parameters_filename(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_projection()) {
    projection_ = new ::research_scann::ProjectionConfig(*from.projection_);
  } else {
    projection_ = nullptr;
  }
  if (from._internal_has_asymmetric_hash()) {
    asymmetric_hash_ = new ::research_scann::AsymmetricHasherConfig(*from.asymmetric_hash_);
  } else {
    asymmetric_hash_ = nullptr;
  }
  if (from._internal_has_min_hash()) {
    min_hash_ = new ::research_scann::MinHasherConfig(*from.min_hash_);
  } else {
    min_hash_ = nullptr;
  }
  if (from._internal_has_pca_hash()) {
    pca_hash_ = new ::research_scann::PcaHasherConfig(*from.pca_hash_);
  } else {
    pca_hash_ = nullptr;
  }
  if (from._internal_has_bit_sampling_hash()) {
    bit_sampling_hash_ = new ::research_scann::BitSamplingHasherConfig(*from.bit_sampling_hash_);
  } else {
    bit_sampling_hash_ = nullptr;
  }
  if (from._internal_has_bnc_hash()) {
    bnc_hash_ = new ::research_scann::BncHasherConfig(*from.bnc_hash_);
  } else {
    bnc_hash_ = nullptr;
  }
  ::memcpy(&num_bits_, &from.num_bits_,
    static_cast<size_t>(reinterpret_cast<char*>(&threshold_type_) -
    reinterpret_cast<char*>(&num_bits_)) + sizeof(threshold_type_));
  // @@protoc_insertion_point(copy_constructor:research_scann.HashConfig)
}

inline void HashConfig::SharedCtor() {
parameters_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&projection_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_bits_) -
    reinterpret_cast<char*>(&projection_)) + sizeof(num_bits_));
threshold_type_ = 1;
}

HashConfig::~HashConfig() {
  // @@protoc_insertion_point(destructor:research_scann.HashConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HashConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  parameters_filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete projection_;
  if (this != internal_default_instance()) delete asymmetric_hash_;
  if (this != internal_default_instance()) delete min_hash_;
  if (this != internal_default_instance()) delete pca_hash_;
  if (this != internal_default_instance()) delete bit_sampling_hash_;
  if (this != internal_default_instance()) delete bnc_hash_;
}

void HashConfig::ArenaDtor(void* object) {
  HashConfig* _this = reinterpret_cast< HashConfig* >(object);
  (void)_this;
}
void HashConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HashConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HashConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.HashConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      parameters_filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(projection_ != nullptr);
      projection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(asymmetric_hash_ != nullptr);
      asymmetric_hash_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(min_hash_ != nullptr);
      min_hash_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(pca_hash_ != nullptr);
      pca_hash_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(bit_sampling_hash_ != nullptr);
      bit_sampling_hash_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(bnc_hash_ != nullptr);
      bnc_hash_->Clear();
    }
  }
  num_bits_ = 0;
  threshold_type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HashConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 num_bits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_bits(&has_bits);
          num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.ProjectionConfig projection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_projection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::HashConfig_ThresholdType_IsValid(val))) {
            _internal_set_threshold_type(static_cast<::research_scann::HashConfig_ThresholdType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string parameters_filename = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_parameters_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "research_scann.HashConfig.parameters_filename");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_asymmetric_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.MinHasherConfig min_hash = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_min_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.PcaHasherConfig pca_hash = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_pca_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_bit_sampling_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.BncHasherConfig bnc_hash = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_bnc_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HashConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.HashConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_bits = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_num_bits(), target);
  }

  // optional .research_scann.ProjectionConfig projection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::projection(this), target, stream);
  }

  // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_threshold_type(), target);
  }

  // optional string parameters_filename = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_parameters_filename().data(), static_cast<int>(this->_internal_parameters_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.HashConfig.parameters_filename");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_parameters_filename(), target);
  }

  // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::asymmetric_hash(this), target, stream);
  }

  // optional .research_scann.MinHasherConfig min_hash = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::min_hash(this), target, stream);
  }

  // optional .research_scann.PcaHasherConfig pca_hash = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::pca_hash(this), target, stream);
  }

  // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::bit_sampling_hash(this), target, stream);
  }

  // optional .research_scann.BncHasherConfig bnc_hash = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::bnc_hash(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.HashConfig)
  return target;
}

size_t HashConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.HashConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string parameters_filename = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parameters_filename());
    }

    // optional .research_scann.ProjectionConfig projection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *projection_);
    }

    // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *asymmetric_hash_);
    }

    // optional .research_scann.MinHasherConfig min_hash = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *min_hash_);
    }

    // optional .research_scann.PcaHasherConfig pca_hash = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pca_hash_);
    }

    // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bit_sampling_hash_);
    }

    // optional .research_scann.BncHasherConfig bnc_hash = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bnc_hash_);
    }

    // optional int32 num_bits = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_bits());
    }

  }
  // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threshold_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HashConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashConfig::GetClassData() const { return &_class_data_; }

void HashConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<HashConfig *>(to)->MergeFrom(
      static_cast<const HashConfig &>(from));
}


void HashConfig::MergeFrom(const HashConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.HashConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_parameters_filename(from._internal_parameters_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_projection()->::research_scann::ProjectionConfig::MergeFrom(from._internal_projection());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_asymmetric_hash()->::research_scann::AsymmetricHasherConfig::MergeFrom(from._internal_asymmetric_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_min_hash()->::research_scann::MinHasherConfig::MergeFrom(from._internal_min_hash());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_pca_hash()->::research_scann::PcaHasherConfig::MergeFrom(from._internal_pca_hash());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_bit_sampling_hash()->::research_scann::BitSamplingHasherConfig::MergeFrom(from._internal_bit_sampling_hash());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_bnc_hash()->::research_scann::BncHasherConfig::MergeFrom(from._internal_bnc_hash());
    }
    if (cached_has_bits & 0x00000080u) {
      num_bits_ = from.num_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_threshold_type(from._internal_threshold_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HashConfig::CopyFrom(const HashConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.HashConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashConfig::IsInitialized() const {
  if (_internal_has_projection()) {
    if (!projection_->IsInitialized()) return false;
  }
  if (_internal_has_asymmetric_hash()) {
    if (!asymmetric_hash_->IsInitialized()) return false;
  }
  return true;
}

void HashConfig::InternalSwap(HashConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &parameters_filename_, GetArenaForAllocation(),
      &other->parameters_filename_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashConfig, num_bits_)
      + sizeof(HashConfig::num_bits_)
      - PROTOBUF_FIELD_OFFSET(HashConfig, projection_)>(
          reinterpret_cast<char*>(&projection_),
          reinterpret_cast<char*>(&other->projection_));
  swap(threshold_type_, other->threshold_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HashConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[0]);
}

// ===================================================================

class AsymmetricHasherConfig_FixedPointLUTConversionOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<AsymmetricHasherConfig_FixedPointLUTConversionOptions>()._has_bits_);
  static void set_has_float_to_int_conversion_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_multiplier_quantile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AsymmetricHasherConfig_FixedPointLUTConversionOptions::AsymmetricHasherConfig_FixedPointLUTConversionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
}
AsymmetricHasherConfig_FixedPointLUTConversionOptions::AsymmetricHasherConfig_FixedPointLUTConversionOptions(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&float_to_int_conversion_method_, &from.float_to_int_conversion_method_,
    static_cast<size_t>(reinterpret_cast<char*>(&multiplier_quantile_) -
    reinterpret_cast<char*>(&float_to_int_conversion_method_)) + sizeof(multiplier_quantile_));
  // @@protoc_insertion_point(copy_constructor:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
}

inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::SharedCtor() {
float_to_int_conversion_method_ = 0;
multiplier_quantile_ = 1;
}

AsymmetricHasherConfig_FixedPointLUTConversionOptions::~AsymmetricHasherConfig_FixedPointLUTConversionOptions() {
  // @@protoc_insertion_point(destructor:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::ArenaDtor(void* object) {
  AsymmetricHasherConfig_FixedPointLUTConversionOptions* _this = reinterpret_cast< AsymmetricHasherConfig_FixedPointLUTConversionOptions* >(object);
  (void)_this;
}
void AsymmetricHasherConfig_FixedPointLUTConversionOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymmetricHasherConfig_FixedPointLUTConversionOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    float_to_int_conversion_method_ = 0;
    multiplier_quantile_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymmetricHasherConfig_FixedPointLUTConversionOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(val))) {
            _internal_set_float_to_int_conversion_method(static_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float multiplier_quantile = 2 [default = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_multiplier_quantile(&has_bits);
          multiplier_quantile_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymmetricHasherConfig_FixedPointLUTConversionOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_float_to_int_conversion_method(), target);
  }

  // optional float multiplier_quantile = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_multiplier_quantile(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  return target;
}

size_t AsymmetricHasherConfig_FixedPointLUTConversionOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_float_to_int_conversion_method());
    }

    // optional float multiplier_quantile = 2 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymmetricHasherConfig_FixedPointLUTConversionOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymmetricHasherConfig_FixedPointLUTConversionOptions::GetClassData() const { return &_class_data_; }

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<AsymmetricHasherConfig_FixedPointLUTConversionOptions *>(to)->MergeFrom(
      static_cast<const AsymmetricHasherConfig_FixedPointLUTConversionOptions &>(from));
}


void AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeFrom(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      float_to_int_conversion_method_ = from.float_to_int_conversion_method_;
    }
    if (cached_has_bits & 0x00000002u) {
      multiplier_quantile_ = from.multiplier_quantile_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::CopyFrom(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymmetricHasherConfig_FixedPointLUTConversionOptions::IsInitialized() const {
  return true;
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::InternalSwap(AsymmetricHasherConfig_FixedPointLUTConversionOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(float_to_int_conversion_method_, other->float_to_int_conversion_method_);
  swap(multiplier_quantile_, other->multiplier_quantile_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymmetricHasherConfig_FixedPointLUTConversionOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[1]);
}

// ===================================================================

class AsymmetricHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AsymmetricHasherConfig>()._has_bits_);
  static const ::research_scann::ProjectionConfig& projection(const AsymmetricHasherConfig* msg);
  static void set_has_projection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_clusters_per_block(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_lookup_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_clustering_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_use_residual_quantization(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_use_normalized_residual_quantization(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_noise_shaping_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_use_norm_biasing_correction(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_use_global_topn(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& fixed_point_lut_conversion_options(const AsymmetricHasherConfig* msg);
  static void set_has_fixed_point_lut_conversion_options(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sampling_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::research_scann::DistanceMeasureConfig& quantization_distance(const AsymmetricHasherConfig* msg);
  static void set_has_quantization_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_clustering_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_clustering_convergence_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_centers_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_machines(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_use_per_leaf_partition_training(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mr_jobname_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ram_gb(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_num_cpus(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_quantization_scheme(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::research_scann::StackedQuantizersConfig& stacked_quantizers_config(const AsymmetricHasherConfig* msg);
  static void set_has_stacked_quantizers_config(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_min_number_machines(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_max_sample_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_use_noise_shaped_training(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_partition_level_confidence_interval_stdevs(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_min_cluster_size(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_use_single_machine_trainer(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::research_scann::ProjectionConfig&
AsymmetricHasherConfig::_Internal::projection(const AsymmetricHasherConfig* msg) {
  return *msg->projection_;
}
const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions&
AsymmetricHasherConfig::_Internal::fixed_point_lut_conversion_options(const AsymmetricHasherConfig* msg) {
  return *msg->fixed_point_lut_conversion_options_;
}
const ::research_scann::DistanceMeasureConfig&
AsymmetricHasherConfig::_Internal::quantization_distance(const AsymmetricHasherConfig* msg) {
  return *msg->quantization_distance_;
}
const ::research_scann::StackedQuantizersConfig&
AsymmetricHasherConfig::_Internal::stacked_quantizers_config(const AsymmetricHasherConfig* msg) {
  return *msg->stacked_quantizers_config_;
}
void AsymmetricHasherConfig::clear_projection() {
  if (projection_ != nullptr) projection_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void AsymmetricHasherConfig::clear_quantization_distance() {
  if (quantization_distance_ != nullptr) quantization_distance_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
AsymmetricHasherConfig::AsymmetricHasherConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.AsymmetricHasherConfig)
}
AsymmetricHasherConfig::AsymmetricHasherConfig(const AsymmetricHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  centers_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_centers_filename()) {
    centers_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_centers_filename(), 
      GetArenaForAllocation());
  }
  mr_jobname_prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_mr_jobname_prefix()) {
    mr_jobname_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mr_jobname_prefix(), 
      GetArenaForAllocation());
  }
  cell_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cell()) {
    cell_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cell(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_projection()) {
    projection_ = new ::research_scann::ProjectionConfig(*from.projection_);
  } else {
    projection_ = nullptr;
  }
  if (from._internal_has_quantization_distance()) {
    quantization_distance_ = new ::research_scann::DistanceMeasureConfig(*from.quantization_distance_);
  } else {
    quantization_distance_ = nullptr;
  }
  if (from._internal_has_stacked_quantizers_config()) {
    stacked_quantizers_config_ = new ::research_scann::StackedQuantizersConfig(*from.stacked_quantizers_config_);
  } else {
    stacked_quantizers_config_ = nullptr;
  }
  if (from._internal_has_fixed_point_lut_conversion_options()) {
    fixed_point_lut_conversion_options_ = new ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions(*from.fixed_point_lut_conversion_options_);
  } else {
    fixed_point_lut_conversion_options_ = nullptr;
  }
  ::memcpy(&min_number_machines_, &from.min_number_machines_,
    static_cast<size_t>(reinterpret_cast<char*>(&noise_shaping_threshold_) -
    reinterpret_cast<char*>(&min_number_machines_)) + sizeof(noise_shaping_threshold_));
  clear_has_SamplingFractionOrExpectedSize();
  switch (from.SamplingFractionOrExpectedSize_case()) {
    case kSamplingFraction: {
      _internal_set_sampling_fraction(from._internal_sampling_fraction());
      break;
    }
    case kExpectedSampleSize: {
      _internal_set_expected_sample_size(from._internal_expected_sample_size());
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:research_scann.AsymmetricHasherConfig)
}

inline void AsymmetricHasherConfig::SharedCtor() {
centers_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
mr_jobname_prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
cell_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&projection_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_global_topn_) -
    reinterpret_cast<char*>(&projection_)) + sizeof(use_global_topn_));
min_cluster_size_ = 1;
num_clusters_per_block_ = 256;
max_sample_size_ = 2147483647;
max_clustering_iterations_ = 10;
clustering_convergence_tolerance_ = 1e-05f;
clustering_seed_ = 1;
sampling_seed_ = 1;
ram_gb_ = 4;
num_cpus_ = 1;
noise_shaping_threshold_ = std::numeric_limits<double>::quiet_NaN();
clear_has_SamplingFractionOrExpectedSize();
}

AsymmetricHasherConfig::~AsymmetricHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.AsymmetricHasherConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymmetricHasherConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  centers_filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mr_jobname_prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cell_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete projection_;
  if (this != internal_default_instance()) delete quantization_distance_;
  if (this != internal_default_instance()) delete stacked_quantizers_config_;
  if (this != internal_default_instance()) delete fixed_point_lut_conversion_options_;
  if (has_SamplingFractionOrExpectedSize()) {
    clear_SamplingFractionOrExpectedSize();
  }
}

void AsymmetricHasherConfig::ArenaDtor(void* object) {
  AsymmetricHasherConfig* _this = reinterpret_cast< AsymmetricHasherConfig* >(object);
  (void)_this;
}
void AsymmetricHasherConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymmetricHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymmetricHasherConfig::clear_SamplingFractionOrExpectedSize() {
// @@protoc_insertion_point(one_of_clear_start:research_scann.AsymmetricHasherConfig)
  switch (SamplingFractionOrExpectedSize_case()) {
    case kSamplingFraction: {
      // No need to clear
      break;
    }
    case kExpectedSampleSize: {
      // No need to clear
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}


void AsymmetricHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.AsymmetricHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      centers_filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      mr_jobname_prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      cell_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(projection_ != nullptr);
      projection_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(quantization_distance_ != nullptr);
      quantization_distance_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(stacked_quantizers_config_ != nullptr);
      stacked_quantizers_config_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(fixed_point_lut_conversion_options_ != nullptr);
      fixed_point_lut_conversion_options_->Clear();
    }
  }
  min_number_machines_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&use_per_leaf_partition_training_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_residual_quantization_) -
        reinterpret_cast<char*>(&use_per_leaf_partition_training_)) + sizeof(use_residual_quantization_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&use_normalized_residual_quantization_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_global_topn_) -
        reinterpret_cast<char*>(&use_normalized_residual_quantization_)) + sizeof(use_global_topn_));
    min_cluster_size_ = 1;
    num_clusters_per_block_ = 256;
    max_sample_size_ = 2147483647;
    max_clustering_iterations_ = 10;
    clustering_convergence_tolerance_ = 1e-05f;
  }
  if (cached_has_bits & 0x1f000000u) {
    clustering_seed_ = 1;
    sampling_seed_ = 1;
    ram_gb_ = 4;
    num_cpus_ = 1;
    noise_shaping_threshold_ = std::numeric_limits<double>::quiet_NaN();
  }
  clear_SamplingFractionOrExpectedSize();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymmetricHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .research_scann.ProjectionConfig projection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_projection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_clusters_per_block = 2 [default = 256];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_clusters_per_block(&has_bits);
          num_clusters_per_block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_sample_size = 3 [default = 2147483647];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_sample_size(&has_bits);
          max_sample_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_clustering_iterations = 4 [default = 10];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_max_clustering_iterations(&has_bits);
          max_clustering_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_clustering_convergence_tolerance(&has_bits);
          clustering_convergence_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional string centers_filename = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_centers_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "research_scann.AsymmetricHasherConfig.centers_filename");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 min_number_machines = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_min_number_machines(&has_bits);
          min_number_machines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_use_single_machine_trainer(&has_bits);
          use_single_machine_trainer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 clustering_seed = 9 [default = 1];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_clustering_seed(&has_bits);
          clustering_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // float sampling_fraction = 10 [default = 1];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _internal_set_sampling_fraction(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 sampling_seed = 11 [default = 1];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_sampling_seed(&has_bits);
          sampling_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string mr_jobname_prefix = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_mr_jobname_prefix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "research_scann.AsymmetricHasherConfig.mr_jobname_prefix");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cell = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_cell();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "research_scann.AsymmetricHasherConfig.cell");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ram_gb = 14 [default = 4];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_ram_gb(&has_bits);
          ram_gb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_cpus = 15 [default = 1];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_num_cpus(&has_bits);
          num_cpus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_per_leaf_partition_training = 17 [default = false];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_use_per_leaf_partition_training(&has_bits);
          use_per_leaf_partition_training_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_quantization_distance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float min_cluster_size = 19 [default = 1, deprecated = true];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 157)) {
          _Internal::set_has_min_cluster_size(&has_bits);
          min_cluster_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::AsymmetricHasherConfig_LookupType_IsValid(val))) {
            _internal_set_lookup_type(static_cast<::research_scann::AsymmetricHasherConfig_LookupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool use_residual_quantization = 22 [default = false];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_use_residual_quantization(&has_bits);
          use_residual_quantization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::AsymmetricHasherConfig_QuantizationScheme_IsValid(val))) {
            _internal_set_quantization_scheme(static_cast<::research_scann::AsymmetricHasherConfig_QuantizationScheme>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(23, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_stacked_quantizers_config(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed_point_lut_conversion_options(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 213)) {
          _Internal::set_has_partition_level_confidence_interval_stdevs(&has_bits);
          partition_level_confidence_interval_stdevs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 num_machines = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_num_machines(&has_bits);
          num_machines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double noise_shaping_threshold = 28 [default = nan];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 225)) {
          _Internal::set_has_noise_shaping_threshold(&has_bits);
          noise_shaping_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // int32 expected_sample_size = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _internal_set_expected_sample_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_noise_shaped_training = 30 [default = false, deprecated = true];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_use_noise_shaped_training(&has_bits);
          use_noise_shaped_training_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_norm_biasing_correction = 31 [default = false];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_use_norm_biasing_correction(&has_bits);
          use_norm_biasing_correction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_normalized_residual_quantization = 32 [default = false];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_use_normalized_residual_quantization(&has_bits);
          use_normalized_residual_quantization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_global_topn = 33 [default = false];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_use_global_topn(&has_bits);
          use_global_topn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymmetricHasherConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.AsymmetricHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .research_scann.ProjectionConfig projection = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::projection(this), target, stream);
  }

  // optional int32 num_clusters_per_block = 2 [default = 256];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_clusters_per_block(), target);
  }

  // optional int32 max_sample_size = 3 [default = 2147483647];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_sample_size(), target);
  }

  // optional int32 max_clustering_iterations = 4 [default = 10];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_clustering_iterations(), target);
  }

  // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_clustering_convergence_tolerance(), target);
  }

  // optional string centers_filename = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_centers_filename().data(), static_cast<int>(this->_internal_centers_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.centers_filename");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_centers_filename(), target);
  }

  // optional int32 min_number_machines = 7 [deprecated = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_min_number_machines(), target);
  }

  // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_use_single_machine_trainer(), target);
  }

  // optional int32 clustering_seed = 9 [default = 1];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_clustering_seed(), target);
  }

  // float sampling_fraction = 10 [default = 1];
  if (_internal_has_sampling_fraction()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_sampling_fraction(), target);
  }

  // optional int32 sampling_seed = 11 [default = 1];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_sampling_seed(), target);
  }

  // optional string mr_jobname_prefix = 12;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mr_jobname_prefix().data(), static_cast<int>(this->_internal_mr_jobname_prefix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.mr_jobname_prefix");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_mr_jobname_prefix(), target);
  }

  // optional string cell = 13;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cell().data(), static_cast<int>(this->_internal_cell().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.cell");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_cell(), target);
  }

  // optional int32 ram_gb = 14 [default = 4];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->_internal_ram_gb(), target);
  }

  // optional int32 num_cpus = 15 [default = 1];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->_internal_num_cpus(), target);
  }

  // optional bool use_per_leaf_partition_training = 17 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_use_per_leaf_partition_training(), target);
  }

  // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::quantization_distance(this), target, stream);
  }

  // optional float min_cluster_size = 19 [default = 1, deprecated = true];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(19, this->_internal_min_cluster_size(), target);
  }

  // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      20, this->_internal_lookup_type(), target);
  }

  // optional bool use_residual_quantization = 22 [default = false];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_use_residual_quantization(), target);
  }

  // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      23, this->_internal_quantization_scheme(), target);
  }

  // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::stacked_quantizers_config(this), target, stream);
  }

  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::fixed_point_lut_conversion_options(this), target, stream);
  }

  // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(26, this->_internal_partition_level_confidence_interval_stdevs(), target);
  }

  // optional int32 num_machines = 27;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(27, this->_internal_num_machines(), target);
  }

  // optional double noise_shaping_threshold = 28 [default = nan];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(28, this->_internal_noise_shaping_threshold(), target);
  }

  // int32 expected_sample_size = 29;
  if (_internal_has_expected_sample_size()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_expected_sample_size(), target);
  }

  // optional bool use_noise_shaped_training = 30 [default = false, deprecated = true];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(30, this->_internal_use_noise_shaped_training(), target);
  }

  // optional bool use_norm_biasing_correction = 31 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_use_norm_biasing_correction(), target);
  }

  // optional bool use_normalized_residual_quantization = 32 [default = false];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->_internal_use_normalized_residual_quantization(), target);
  }

  // optional bool use_global_topn = 33 [default = false];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(33, this->_internal_use_global_topn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.AsymmetricHasherConfig)
  return target;
}

size_t AsymmetricHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.AsymmetricHasherConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string centers_filename = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_centers_filename());
    }

    // optional string mr_jobname_prefix = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mr_jobname_prefix());
    }

    // optional string cell = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cell());
    }

    // optional .research_scann.ProjectionConfig projection = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *projection_);
    }

    // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *quantization_distance_);
    }

    // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stacked_quantizers_config_);
    }

    // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fixed_point_lut_conversion_options_);
    }

    // optional int32 min_number_machines = 7 [deprecated = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_min_number_machines());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool use_per_leaf_partition_training = 17 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool use_noise_shaped_training = 30 [default = false, deprecated = true];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_lookup_type());
    }

    // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_quantization_scheme());
    }

    // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional int32 num_machines = 27;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_machines());
    }

    // optional bool use_residual_quantization = 22 [default = false];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool use_normalized_residual_quantization = 32 [default = false];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool use_norm_biasing_correction = 31 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool use_global_topn = 33 [default = false];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional float min_cluster_size = 19 [default = 1, deprecated = true];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional int32 num_clusters_per_block = 2 [default = 256];
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_clusters_per_block());
    }

    // optional int32 max_sample_size = 3 [default = 2147483647];
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_sample_size());
    }

    // optional int32 max_clustering_iterations = 4 [default = 10];
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_clustering_iterations());
    }

    // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x1f000000u) {
    // optional int32 clustering_seed = 9 [default = 1];
    if (cached_has_bits & 0x01000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_clustering_seed());
    }

    // optional int32 sampling_seed = 11 [default = 1];
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_sampling_seed());
    }

    // optional int32 ram_gb = 14 [default = 4];
    if (cached_has_bits & 0x04000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_ram_gb());
    }

    // optional int32 num_cpus = 15 [default = 1];
    if (cached_has_bits & 0x08000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_cpus());
    }

    // optional double noise_shaping_threshold = 28 [default = nan];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

  }
  switch (SamplingFractionOrExpectedSize_case()) {
    // float sampling_fraction = 10 [default = 1];
    case kSamplingFraction: {
      total_size += 1 + 4;
      break;
    }
    // int32 expected_sample_size = 29;
    case kExpectedSampleSize: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_expected_sample_size());
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymmetricHasherConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymmetricHasherConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymmetricHasherConfig::GetClassData() const { return &_class_data_; }

void AsymmetricHasherConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<AsymmetricHasherConfig *>(to)->MergeFrom(
      static_cast<const AsymmetricHasherConfig &>(from));
}


void AsymmetricHasherConfig::MergeFrom(const AsymmetricHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.AsymmetricHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_centers_filename(from._internal_centers_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_mr_jobname_prefix(from._internal_mr_jobname_prefix());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_cell(from._internal_cell());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_projection()->::research_scann::ProjectionConfig::MergeFrom(from._internal_projection());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_quantization_distance()->::research_scann::DistanceMeasureConfig::MergeFrom(from._internal_quantization_distance());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_stacked_quantizers_config()->::research_scann::StackedQuantizersConfig::MergeFrom(from._internal_stacked_quantizers_config());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_fixed_point_lut_conversion_options()->::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeFrom(from._internal_fixed_point_lut_conversion_options());
    }
    if (cached_has_bits & 0x00000080u) {
      min_number_machines_ = from.min_number_machines_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      use_per_leaf_partition_training_ = from.use_per_leaf_partition_training_;
    }
    if (cached_has_bits & 0x00000200u) {
      use_noise_shaped_training_ = from.use_noise_shaped_training_;
    }
    if (cached_has_bits & 0x00000400u) {
      use_single_machine_trainer_ = from.use_single_machine_trainer_;
    }
    if (cached_has_bits & 0x00000800u) {
      lookup_type_ = from.lookup_type_;
    }
    if (cached_has_bits & 0x00001000u) {
      quantization_scheme_ = from.quantization_scheme_;
    }
    if (cached_has_bits & 0x00002000u) {
      partition_level_confidence_interval_stdevs_ = from.partition_level_confidence_interval_stdevs_;
    }
    if (cached_has_bits & 0x00004000u) {
      num_machines_ = from.num_machines_;
    }
    if (cached_has_bits & 0x00008000u) {
      use_residual_quantization_ = from.use_residual_quantization_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      use_normalized_residual_quantization_ = from.use_normalized_residual_quantization_;
    }
    if (cached_has_bits & 0x00020000u) {
      use_norm_biasing_correction_ = from.use_norm_biasing_correction_;
    }
    if (cached_has_bits & 0x00040000u) {
      use_global_topn_ = from.use_global_topn_;
    }
    if (cached_has_bits & 0x00080000u) {
      min_cluster_size_ = from.min_cluster_size_;
    }
    if (cached_has_bits & 0x00100000u) {
      num_clusters_per_block_ = from.num_clusters_per_block_;
    }
    if (cached_has_bits & 0x00200000u) {
      max_sample_size_ = from.max_sample_size_;
    }
    if (cached_has_bits & 0x00400000u) {
      max_clustering_iterations_ = from.max_clustering_iterations_;
    }
    if (cached_has_bits & 0x00800000u) {
      clustering_convergence_tolerance_ = from.clustering_convergence_tolerance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x1f000000u) {
    if (cached_has_bits & 0x01000000u) {
      clustering_seed_ = from.clustering_seed_;
    }
    if (cached_has_bits & 0x02000000u) {
      sampling_seed_ = from.sampling_seed_;
    }
    if (cached_has_bits & 0x04000000u) {
      ram_gb_ = from.ram_gb_;
    }
    if (cached_has_bits & 0x08000000u) {
      num_cpus_ = from.num_cpus_;
    }
    if (cached_has_bits & 0x10000000u) {
      noise_shaping_threshold_ = from.noise_shaping_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.SamplingFractionOrExpectedSize_case()) {
    case kSamplingFraction: {
      _internal_set_sampling_fraction(from._internal_sampling_fraction());
      break;
    }
    case kExpectedSampleSize: {
      _internal_set_expected_sample_size(from._internal_expected_sample_size());
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymmetricHasherConfig::CopyFrom(const AsymmetricHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.AsymmetricHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymmetricHasherConfig::IsInitialized() const {
  if (_internal_has_projection()) {
    if (!projection_->IsInitialized()) return false;
  }
  return true;
}

void AsymmetricHasherConfig::InternalSwap(AsymmetricHasherConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &centers_filename_, GetArenaForAllocation(),
      &other->centers_filename_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mr_jobname_prefix_, GetArenaForAllocation(),
      &other->mr_jobname_prefix_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &cell_, GetArenaForAllocation(),
      &other->cell_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AsymmetricHasherConfig, use_global_topn_)
      + sizeof(AsymmetricHasherConfig::use_global_topn_)
      - PROTOBUF_FIELD_OFFSET(AsymmetricHasherConfig, projection_)>(
          reinterpret_cast<char*>(&projection_),
          reinterpret_cast<char*>(&other->projection_));
  swap(min_cluster_size_, other->min_cluster_size_);
  swap(num_clusters_per_block_, other->num_clusters_per_block_);
  swap(max_sample_size_, other->max_sample_size_);
  swap(max_clustering_iterations_, other->max_clustering_iterations_);
  swap(clustering_convergence_tolerance_, other->clustering_convergence_tolerance_);
  swap(clustering_seed_, other->clustering_seed_);
  swap(sampling_seed_, other->sampling_seed_);
  swap(ram_gb_, other->ram_gb_);
  swap(num_cpus_, other->num_cpus_);
  swap(noise_shaping_threshold_, other->noise_shaping_threshold_);
  swap(SamplingFractionOrExpectedSize_, other->SamplingFractionOrExpectedSize_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymmetricHasherConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[2]);
}

// ===================================================================

class MinHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<MinHasherConfig>()._has_bits_);
  static void set_has_config_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_sketches(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_bits_per_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MinHasherConfig::MinHasherConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  seeds_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.MinHasherConfig)
}
MinHasherConfig::MinHasherConfig(const MinHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      seeds_(from.seeds_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&config_id_, &from.config_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_bits_per_hash_) -
    reinterpret_cast<char*>(&config_id_)) + sizeof(num_bits_per_hash_));
  // @@protoc_insertion_point(copy_constructor:research_scann.MinHasherConfig)
}

inline void MinHasherConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_bits_per_hash_) -
    reinterpret_cast<char*>(&config_id_)) + sizeof(num_bits_per_hash_));
}

MinHasherConfig::~MinHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.MinHasherConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MinHasherConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MinHasherConfig::ArenaDtor(void* object) {
  MinHasherConfig* _this = reinterpret_cast< MinHasherConfig* >(object);
  (void)_this;
}
void MinHasherConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MinHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MinHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.MinHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  seeds_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&config_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_bits_per_hash_) -
        reinterpret_cast<char*>(&config_id_)) + sizeof(num_bits_per_hash_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MinHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 config_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_config_id(&has_bits);
          config_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_sketches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_sketches(&has_bits);
          num_sketches_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_hashes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_hashes(&has_bits);
          num_hashes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 seeds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_seeds(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_seeds(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_bits_per_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_num_bits_per_hash(&has_bits);
          num_bits_per_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MinHasherConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.MinHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 config_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_config_id(), target);
  }

  // optional int32 num_sketches = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_sketches(), target);
  }

  // optional int32 num_hashes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_hashes(), target);
  }

  // repeated int64 seeds = 4;
  for (int i = 0, n = this->_internal_seeds_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_seeds(i), target);
  }

  // optional int32 num_bits_per_hash = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_num_bits_per_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.MinHasherConfig)
  return target;
}

size_t MinHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.MinHasherConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 seeds = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->seeds_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_seeds_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 config_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_config_id());
    }

    // optional int32 num_sketches = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_sketches());
    }

    // optional int32 num_hashes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_hashes());
    }

    // optional int32 num_bits_per_hash = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_bits_per_hash());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MinHasherConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MinHasherConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MinHasherConfig::GetClassData() const { return &_class_data_; }

void MinHasherConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<MinHasherConfig *>(to)->MergeFrom(
      static_cast<const MinHasherConfig &>(from));
}


void MinHasherConfig::MergeFrom(const MinHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.MinHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  seeds_.MergeFrom(from.seeds_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      config_id_ = from.config_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_sketches_ = from.num_sketches_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_hashes_ = from.num_hashes_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_bits_per_hash_ = from.num_bits_per_hash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MinHasherConfig::CopyFrom(const MinHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.MinHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MinHasherConfig::IsInitialized() const {
  return true;
}

void MinHasherConfig::InternalSwap(MinHasherConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  seeds_.InternalSwap(&other->seeds_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MinHasherConfig, num_bits_per_hash_)
      + sizeof(MinHasherConfig::num_bits_per_hash_)
      - PROTOBUF_FIELD_OFFSET(MinHasherConfig, config_id_)>(
          reinterpret_cast<char*>(&config_id_),
          reinterpret_cast<char*>(&other->config_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MinHasherConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[3]);
}

// ===================================================================

class BitSamplingHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<BitSamplingHasherConfig>()._has_bits_);
  static void set_has_num_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_use_entropy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BitSamplingHasherConfig::BitSamplingHasherConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.BitSamplingHasherConfig)
}
BitSamplingHasherConfig::BitSamplingHasherConfig(const BitSamplingHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&use_entropy_, &from.use_entropy_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_bits_) -
    reinterpret_cast<char*>(&use_entropy_)) + sizeof(num_bits_));
  // @@protoc_insertion_point(copy_constructor:research_scann.BitSamplingHasherConfig)
}

inline void BitSamplingHasherConfig::SharedCtor() {
use_entropy_ = false;
num_bits_ = 3;
}

BitSamplingHasherConfig::~BitSamplingHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.BitSamplingHasherConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BitSamplingHasherConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BitSamplingHasherConfig::ArenaDtor(void* object) {
  BitSamplingHasherConfig* _this = reinterpret_cast< BitSamplingHasherConfig* >(object);
  (void)_this;
}
void BitSamplingHasherConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BitSamplingHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BitSamplingHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.BitSamplingHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    use_entropy_ = false;
    num_bits_ = 3;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BitSamplingHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 num_bits = 1 [default = 3];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_bits(&has_bits);
          num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_entropy = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_use_entropy(&has_bits);
          use_entropy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BitSamplingHasherConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.BitSamplingHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_bits = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_num_bits(), target);
  }

  // optional bool use_entropy = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_use_entropy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.BitSamplingHasherConfig)
  return target;
}

size_t BitSamplingHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.BitSamplingHasherConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool use_entropy = 2 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 num_bits = 1 [default = 3];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_bits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BitSamplingHasherConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BitSamplingHasherConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BitSamplingHasherConfig::GetClassData() const { return &_class_data_; }

void BitSamplingHasherConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<BitSamplingHasherConfig *>(to)->MergeFrom(
      static_cast<const BitSamplingHasherConfig &>(from));
}


void BitSamplingHasherConfig::MergeFrom(const BitSamplingHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.BitSamplingHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      use_entropy_ = from.use_entropy_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_bits_ = from.num_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BitSamplingHasherConfig::CopyFrom(const BitSamplingHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.BitSamplingHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitSamplingHasherConfig::IsInitialized() const {
  return true;
}

void BitSamplingHasherConfig::InternalSwap(BitSamplingHasherConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(use_entropy_, other->use_entropy_);
  swap(num_bits_, other->num_bits_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BitSamplingHasherConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[4]);
}

// ===================================================================

class PcaHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<PcaHasherConfig>()._has_bits_);
  static void set_has_rotate_projections(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sampling_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sampling_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_sample_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_learn_projections(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_num_iteration(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_iteration_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

PcaHasherConfig::PcaHasherConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.PcaHasherConfig)
}
PcaHasherConfig::PcaHasherConfig(const PcaHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&rotate_projections_, &from.rotate_projections_,
    static_cast<size_t>(reinterpret_cast<char*>(&iteration_tolerance_) -
    reinterpret_cast<char*>(&rotate_projections_)) + sizeof(iteration_tolerance_));
  // @@protoc_insertion_point(copy_constructor:research_scann.PcaHasherConfig)
}

inline void PcaHasherConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rotate_projections_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_sample_size_) -
    reinterpret_cast<char*>(&rotate_projections_)) + sizeof(max_sample_size_));
sampling_fraction_ = 1;
sampling_seed_ = 1;
max_num_iteration_ = 40;
iteration_tolerance_ = 1e-05f;
}

PcaHasherConfig::~PcaHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.PcaHasherConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PcaHasherConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PcaHasherConfig::ArenaDtor(void* object) {
  PcaHasherConfig* _this = reinterpret_cast< PcaHasherConfig* >(object);
  (void)_this;
}
void PcaHasherConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PcaHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PcaHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.PcaHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&rotate_projections_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_sample_size_) -
        reinterpret_cast<char*>(&rotate_projections_)) + sizeof(max_sample_size_));
    sampling_fraction_ = 1;
    sampling_seed_ = 1;
    max_num_iteration_ = 40;
    iteration_tolerance_ = 1e-05f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PcaHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool rotate_projections = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_rotate_projections(&has_bits);
          rotate_projections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float sampling_fraction = 2 [default = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_sampling_fraction(&has_bits);
          sampling_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 sampling_seed = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_sampling_seed(&has_bits);
          sampling_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_sample_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_max_sample_size(&has_bits);
          max_sample_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool learn_projections = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_learn_projections(&has_bits);
          learn_projections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_num_iteration = 6 [default = 40];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_max_num_iteration(&has_bits);
          max_num_iteration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float iteration_tolerance = 7 [default = 1e-05];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_iteration_tolerance(&has_bits);
          iteration_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PcaHasherConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.PcaHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool rotate_projections = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_rotate_projections(), target);
  }

  // optional float sampling_fraction = 2 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_sampling_fraction(), target);
  }

  // optional int32 sampling_seed = 3 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_sampling_seed(), target);
  }

  // optional int32 max_sample_size = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_sample_size(), target);
  }

  // optional bool learn_projections = 5 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_learn_projections(), target);
  }

  // optional int32 max_num_iteration = 6 [default = 40];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_max_num_iteration(), target);
  }

  // optional float iteration_tolerance = 7 [default = 1e-05];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_iteration_tolerance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.PcaHasherConfig)
  return target;
}

size_t PcaHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.PcaHasherConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bool rotate_projections = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool learn_projections = 5 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 max_sample_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_sample_size());
    }

    // optional float sampling_fraction = 2 [default = 1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 sampling_seed = 3 [default = 1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_sampling_seed());
    }

    // optional int32 max_num_iteration = 6 [default = 40];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_num_iteration());
    }

    // optional float iteration_tolerance = 7 [default = 1e-05];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PcaHasherConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PcaHasherConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PcaHasherConfig::GetClassData() const { return &_class_data_; }

void PcaHasherConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<PcaHasherConfig *>(to)->MergeFrom(
      static_cast<const PcaHasherConfig &>(from));
}


void PcaHasherConfig::MergeFrom(const PcaHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.PcaHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      rotate_projections_ = from.rotate_projections_;
    }
    if (cached_has_bits & 0x00000002u) {
      learn_projections_ = from.learn_projections_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_sample_size_ = from.max_sample_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      sampling_fraction_ = from.sampling_fraction_;
    }
    if (cached_has_bits & 0x00000010u) {
      sampling_seed_ = from.sampling_seed_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_num_iteration_ = from.max_num_iteration_;
    }
    if (cached_has_bits & 0x00000040u) {
      iteration_tolerance_ = from.iteration_tolerance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PcaHasherConfig::CopyFrom(const PcaHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.PcaHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PcaHasherConfig::IsInitialized() const {
  return true;
}

void PcaHasherConfig::InternalSwap(PcaHasherConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PcaHasherConfig, max_sample_size_)
      + sizeof(PcaHasherConfig::max_sample_size_)
      - PROTOBUF_FIELD_OFFSET(PcaHasherConfig, rotate_projections_)>(
          reinterpret_cast<char*>(&rotate_projections_),
          reinterpret_cast<char*>(&other->rotate_projections_));
  swap(sampling_fraction_, other->sampling_fraction_);
  swap(sampling_seed_, other->sampling_seed_);
  swap(max_num_iteration_, other->max_num_iteration_);
  swap(iteration_tolerance_, other->iteration_tolerance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PcaHasherConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[5]);
}

// ===================================================================

class BncHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<BncHasherConfig>()._has_bits_);
  static void set_has_compression_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gamma(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_learning_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_batch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_phase1_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_phase2_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sampling_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_cpus(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BncHasherConfig::BncHasherConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.BncHasherConfig)
}
BncHasherConfig::BncHasherConfig(const BncHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&compression_ratio_, &from.compression_ratio_,
    static_cast<size_t>(reinterpret_cast<char*>(&sampling_seed_) -
    reinterpret_cast<char*>(&compression_ratio_)) + sizeof(sampling_seed_));
  // @@protoc_insertion_point(copy_constructor:research_scann.BncHasherConfig)
}

inline void BncHasherConfig::SharedCtor() {
compression_ratio_ = 0;
num_cpus_ = 1;
gamma_ = 10;
learning_rate_ = 0.1f;
batch_size_ = 128;
num_phase1_iterations_ = 50;
num_phase2_iterations_ = 100;
sampling_seed_ = 1;
}

BncHasherConfig::~BncHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.BncHasherConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BncHasherConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BncHasherConfig::ArenaDtor(void* object) {
  BncHasherConfig* _this = reinterpret_cast< BncHasherConfig* >(object);
  (void)_this;
}
void BncHasherConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BncHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BncHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.BncHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    compression_ratio_ = 0;
    num_cpus_ = 1;
    gamma_ = 10;
    learning_rate_ = 0.1f;
    batch_size_ = 128;
    num_phase1_iterations_ = 50;
    num_phase2_iterations_ = 100;
    sampling_seed_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BncHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float compression_ratio = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_compression_ratio(&has_bits);
          compression_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float gamma = 2 [default = 10];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_gamma(&has_bits);
          gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float learning_rate = 3 [default = 0.1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_learning_rate(&has_bits);
          learning_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 batch_size = 4 [default = 128];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_batch_size(&has_bits);
          batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_phase1_iterations = 5 [default = 50];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_num_phase1_iterations(&has_bits);
          num_phase1_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_phase2_iterations = 6 [default = 100];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_num_phase2_iterations(&has_bits);
          num_phase2_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 sampling_seed = 7 [default = 1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_sampling_seed(&has_bits);
          sampling_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_cpus = 8 [default = 1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_num_cpus(&has_bits);
          num_cpus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BncHasherConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.BncHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float compression_ratio = 1 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_compression_ratio(), target);
  }

  // optional float gamma = 2 [default = 10];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_gamma(), target);
  }

  // optional float learning_rate = 3 [default = 0.1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_learning_rate(), target);
  }

  // optional int32 batch_size = 4 [default = 128];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_batch_size(), target);
  }

  // optional int32 num_phase1_iterations = 5 [default = 50];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_num_phase1_iterations(), target);
  }

  // optional int32 num_phase2_iterations = 6 [default = 100];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_num_phase2_iterations(), target);
  }

  // optional int32 sampling_seed = 7 [default = 1];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_sampling_seed(), target);
  }

  // optional int32 num_cpus = 8 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_num_cpus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.BncHasherConfig)
  return target;
}

size_t BncHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.BncHasherConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float compression_ratio = 1 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 num_cpus = 8 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_cpus());
    }

    // optional float gamma = 2 [default = 10];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float learning_rate = 3 [default = 0.1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 batch_size = 4 [default = 128];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_batch_size());
    }

    // optional int32 num_phase1_iterations = 5 [default = 50];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_phase1_iterations());
    }

    // optional int32 num_phase2_iterations = 6 [default = 100];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_phase2_iterations());
    }

    // optional int32 sampling_seed = 7 [default = 1];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_sampling_seed());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BncHasherConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BncHasherConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BncHasherConfig::GetClassData() const { return &_class_data_; }

void BncHasherConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<BncHasherConfig *>(to)->MergeFrom(
      static_cast<const BncHasherConfig &>(from));
}


void BncHasherConfig::MergeFrom(const BncHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.BncHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      compression_ratio_ = from.compression_ratio_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_cpus_ = from.num_cpus_;
    }
    if (cached_has_bits & 0x00000004u) {
      gamma_ = from.gamma_;
    }
    if (cached_has_bits & 0x00000008u) {
      learning_rate_ = from.learning_rate_;
    }
    if (cached_has_bits & 0x00000010u) {
      batch_size_ = from.batch_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      num_phase1_iterations_ = from.num_phase1_iterations_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_phase2_iterations_ = from.num_phase2_iterations_;
    }
    if (cached_has_bits & 0x00000080u) {
      sampling_seed_ = from.sampling_seed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BncHasherConfig::CopyFrom(const BncHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.BncHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BncHasherConfig::IsInitialized() const {
  return true;
}

void BncHasherConfig::InternalSwap(BncHasherConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(compression_ratio_, other->compression_ratio_);
  swap(num_cpus_, other->num_cpus_);
  swap(gamma_, other->gamma_);
  swap(learning_rate_, other->learning_rate_);
  swap(batch_size_, other->batch_size_);
  swap(num_phase1_iterations_, other->num_phase1_iterations_);
  swap(num_phase2_iterations_, other->num_phase2_iterations_);
  swap(sampling_seed_, other->sampling_seed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BncHasherConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[6]);
}

// ===================================================================

class StackedQuantizersConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<StackedQuantizersConfig>()._has_bits_);
  static void set_has_min_num_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_num_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_relative_improvement_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StackedQuantizersConfig::StackedQuantizersConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:research_scann.StackedQuantizersConfig)
}
StackedQuantizersConfig::StackedQuantizersConfig(const StackedQuantizersConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&relative_improvement_threshold_, &from.relative_improvement_threshold_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_num_iterations_) -
    reinterpret_cast<char*>(&relative_improvement_threshold_)) + sizeof(max_num_iterations_));
  // @@protoc_insertion_point(copy_constructor:research_scann.StackedQuantizersConfig)
}

inline void StackedQuantizersConfig::SharedCtor() {
relative_improvement_threshold_ = 0.001f;
min_num_iterations_ = 3;
max_num_iterations_ = 10;
}

StackedQuantizersConfig::~StackedQuantizersConfig() {
  // @@protoc_insertion_point(destructor:research_scann.StackedQuantizersConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StackedQuantizersConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StackedQuantizersConfig::ArenaDtor(void* object) {
  StackedQuantizersConfig* _this = reinterpret_cast< StackedQuantizersConfig* >(object);
  (void)_this;
}
void StackedQuantizersConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StackedQuantizersConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StackedQuantizersConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.StackedQuantizersConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    relative_improvement_threshold_ = 0.001f;
    min_num_iterations_ = 3;
    max_num_iterations_ = 10;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StackedQuantizersConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 min_num_iterations = 1 [default = 3];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_min_num_iterations(&has_bits);
          min_num_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_num_iterations = 2 [default = 10];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_num_iterations(&has_bits);
          max_num_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float relative_improvement_threshold = 3 [default = 0.001];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_relative_improvement_threshold(&has_bits);
          relative_improvement_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StackedQuantizersConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.StackedQuantizersConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 min_num_iterations = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_min_num_iterations(), target);
  }

  // optional int32 max_num_iterations = 2 [default = 10];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_max_num_iterations(), target);
  }

  // optional float relative_improvement_threshold = 3 [default = 0.001];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_relative_improvement_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.StackedQuantizersConfig)
  return target;
}

size_t StackedQuantizersConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.StackedQuantizersConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float relative_improvement_threshold = 3 [default = 0.001];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 min_num_iterations = 1 [default = 3];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_min_num_iterations());
    }

    // optional int32 max_num_iterations = 2 [default = 10];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_num_iterations());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StackedQuantizersConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StackedQuantizersConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StackedQuantizersConfig::GetClassData() const { return &_class_data_; }

void StackedQuantizersConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<StackedQuantizersConfig *>(to)->MergeFrom(
      static_cast<const StackedQuantizersConfig &>(from));
}


void StackedQuantizersConfig::MergeFrom(const StackedQuantizersConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.StackedQuantizersConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      relative_improvement_threshold_ = from.relative_improvement_threshold_;
    }
    if (cached_has_bits & 0x00000002u) {
      min_num_iterations_ = from.min_num_iterations_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_num_iterations_ = from.max_num_iterations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StackedQuantizersConfig::CopyFrom(const StackedQuantizersConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.StackedQuantizersConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StackedQuantizersConfig::IsInitialized() const {
  return true;
}

void StackedQuantizersConfig::InternalSwap(StackedQuantizersConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(relative_improvement_threshold_, other->relative_improvement_threshold_);
  swap(min_num_iterations_, other->min_num_iterations_);
  swap(max_num_iterations_, other->max_num_iterations_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StackedQuantizersConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_scann_2fproto_2fhash_2eproto_getter, &descriptor_table_scann_2fproto_2fhash_2eproto_once,
      file_level_metadata_scann_2fproto_2fhash_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace research_scann
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::research_scann::HashConfig* Arena::CreateMaybeMessage< ::research_scann::HashConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::HashConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* Arena::CreateMaybeMessage< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::AsymmetricHasherConfig* Arena::CreateMaybeMessage< ::research_scann::AsymmetricHasherConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::AsymmetricHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::MinHasherConfig* Arena::CreateMaybeMessage< ::research_scann::MinHasherConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::MinHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::BitSamplingHasherConfig* Arena::CreateMaybeMessage< ::research_scann::BitSamplingHasherConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::BitSamplingHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::PcaHasherConfig* Arena::CreateMaybeMessage< ::research_scann::PcaHasherConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::PcaHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::BncHasherConfig* Arena::CreateMaybeMessage< ::research_scann::BncHasherConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::BncHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::StackedQuantizersConfig* Arena::CreateMaybeMessage< ::research_scann::StackedQuantizersConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::research_scann::StackedQuantizersConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
